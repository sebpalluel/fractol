FUNCTION  xolox#easytags#update#with_vim()
Called 1 time
Total time:  13.407920
 Self time:   0.115128

count  total (s)   self (s)
    1              0.000001   let counters = {}
    1   0.000007   0.000002   let starttime = xolox#misc#timer#start()
    1   0.000013   0.000006   call xolox#misc#msg#debug("easytags.vim %s: Executing %s.", g:xolox#easytags#version, a:params['command'])
    1   0.018034   0.000018   let lines = xolox#misc#os#exec({'command': a:params['command']})['stdout']
    1   0.000300   0.000011   let entries = xolox#easytags#update#parse_entries(lines)
    1              0.000004   let counters['num_updated'] = len(entries)
    1              0.000004   let directory = get(a:params, 'directory', '')
    1   0.000040   0.000009   let cache = s:create_cache()
    1              0.000002   if !empty(directory)
                                let counters['num_filtered'] = s:save_by_filetype(a:params['filter_tags'], [], entries, cache, directory)
                              else
    1  13.389335   0.115037     let counters['num_filtered'] = s:filter_merge_tags(a:params['filter_tags'], a:params['tagsfile'], entries, cache)
    1              0.000004   endif
    1   0.000160   0.000014   let counters['elapsed_time'] = xolox#misc#timer#convert(starttime)
    1              0.000002   return counters

FUNCTION  354()
Called 1 time
Total time:   0.000041
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000041   0.000016     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  358()
Called 2 times
Total time:   0.000038
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000038   0.000019     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  syntastic#log#debugShowOptions()
Called 1 time
Total time:   0.000012
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000009   0.000005     if !s:_isDebugEnabled(a:level)
    1              0.000002         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  Insert_header_42_add_info()
Called 1 time
Total time:   0.012864
 Self time:   0.000715

count  total (s)   self (s)
    1              0.000025 	let l:line = "/*   " . a:begin . ": " . strftime("%Y/%m/%d %H:%M:%S") . " by " . s:author
    1              0.000004 	let l:cmd = "echo " . s:author . " | wc -c | awk '{print $1}' | tr -d '\n'"
    1   0.012400   0.000251 	let l:len = system(l:cmd)
    1              0.000024 	let l:space = 17 - l:len
   10              0.000029 	while l:space >= 0
    9              0.000031 		let l:line = l:line . " "
    9              0.000018 		let l:space -= 1
    9              0.000011 	endwhile
    1              0.000005 	let l:line = l:line . a:end
    1              0.000003 	if a:setline ==? '1'
    1              0.000287 		call setline(a:nul_line, l:line)
    1              0.000002 	else
                            		call append(a:nul_line, l:line)
                            	endif

FUNCTION  <SNR>79_get()
Called 108 times
Total time:   0.001678
 Self time:   0.001678

count  total (s)   self (s)
  108              0.000094   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
   12              0.000052     let bufoptions = get(s:options, bufnr('%'), {})
   12              0.000049     return deepcopy(get(bufoptions, a:name, a:1))
                              else
   96              0.000566     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  <SNR>44__compare_error_items_by_columns()
Called 6 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    6              0.000009     if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
    6              0.000009         return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif

FUNCTION  syntastic#log#debug()
Called 31 times
Total time:   0.000317
 Self time:   0.000214

count  total (s)   self (s)
   31   0.000258   0.000155     if !s:_isDebugEnabled(a:level)
   31              0.000026         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>44__remove_shadowed_items()
Called 6 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
                                " keep only the first message at a given column
    6              0.000005     let i = 0
    9              0.000014     while i < len(a:errors) - 1
    3              0.000004         let j = i + 1
    3              0.000002         let dupes = 0
    3              0.000008         while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
    3              0.000002         if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
    3              0.000003         let i += 1
    3              0.000009     endwhile
                            
                                " merge messages with the same text
    6              0.000006     let i = 0
    9              0.000015     while i < len(a:errors) - 1
    3              0.000003         let j = i + 1
    3              0.000002         let dupes = 0
    3              0.000008         while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
    3              0.000002         if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
    3              0.000003         let i += 1
    3              0.000000     endwhile

FUNCTION  <SNR>118__get_checker_var()
Called 7 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
    7              0.000021     let prefix = a:scope . ':' . 'syntastic_'
    7              0.000046     if exists(prefix . a:filetype . '_' . a:subchecker . '_' . a:name)
                                    return {a:scope}:syntastic_{a:filetype}_{a:subchecker}_{a:name}
                                elseif exists(prefix . a:filetype . '_' . a:name)
    1              0.000007         return {a:scope}:syntastic_{a:filetype}_{a:name}
                                else
    6              0.000006         return a:default
                                endif

FUNCTION  <SNR>121_AutoUpdate()
Called 3 times
Total time:   0.000526
 Self time:   0.000410

count  total (s)   self (s)
    3   0.000053   0.000031     call s:debug('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
    3              0.000006     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    3              0.000006     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call s:debug('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
    3              0.000204     let bufnr = bufnr(a:fname)
    3              0.000009     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    3              0.000004     if ftype == 'tagbar'
                                    call s:debug('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    3              0.000016     let sftype = get(split(ftype, '\.'), 0, '')
    3   0.000064   0.000047     call s:debug("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    3   0.000076   0.000014     if !s:IsValidFile(a:fname, sftype)
    3   0.000022   0.000007         call s:debug('Not a valid file, stopping processing')
    3              0.000007         let s:nearby_disabled = 1
    3              0.000002         return
                                endif
                            
                                let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
                                if s:known_files.has(a:fname)
                                    let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
                                    if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call s:debug('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
                                    else
                                        call s:debug('File data seems up to date [' . a:fname . ']')
                                    endif
                                elseif !s:known_files.has(a:fname)
                                    call s:debug('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
                                if no_display
                                    return
                                endif
                            
                                let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
                                if empty(fileinfo)
                                    call s:debug('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
                                if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(s:TagbarState().getCurrent(0)) && a:fname != s:TagbarState().getCurrent(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
                                if !empty(fileinfo)
                                    call s:debug('Setting current file [' . a:fname . ']')
                                    call s:TagbarState().setCurrent(fileinfo)
                                    let s:nearby_disabled = 0
                                endif
                            
                                call s:HighlightTag(0)
                                call s:SetStatusLine()
                                call s:debug('AutoUpdate finished successfully')

FUNCTION  xolox#misc#timer#convert()
Called 1 time
Total time:   0.000146
 Self time:   0.000054

count  total (s)   self (s)
                              " Convert the value returned by `xolox#misc#timer#start()` to a string
                              " representation of the elapsed time since `xolox#misc#timer#start()` was
                              " called. Other values are returned unmodified (this allows using it with
                              " Vim's [map()][] function).
                              "
                              " [map()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#map()
    1              0.000010   if type(a:value) == type([]) && len(a:value) == 2 && a:value[0] == s:unique_marker
    1              0.000001     if s:has_reltime
    1   0.000034   0.000014       let ts = xolox#misc#str#trim(reltimestr(reltime(a:value[1])))
    1              0.000001     else
                                  let ts = localtime() - a:value[1]
                                endif
    1   0.000093   0.000021     return xolox#misc#format#timestamp(ts)
                              endif
                              return a:value

FUNCTION  xolox#misc#escape#shell()
Called 7 times
Total time:   0.000170
 Self time:   0.000116

count  total (s)   self (s)
                              " Takes a single string argument and converts it into a quoted command line
                              " argument.
                              "
                              " I was going to add a long rant here about Vim's ['shellslash' option]
                              " [shellslash], but really, it won't make any difference. Let's just suffice
                              " to say that I have yet to encounter a single person out there who uses
                              " this option for its intended purpose (running a UNIX style shell on
                              " Microsoft Windows).
                              "
                              " [shellslash]: http://vimdoc.sourceforge.net/htmldoc/options.html#'shellslash'
    7   0.000072   0.000018   if xolox#misc#os#is_win()
                                try
                                  let ssl_save = &shellslash
                                  set noshellslash
                                  return shellescape(a:string)
                                finally
                                  let &shellslash = ssl_save
                                endtry
                              else
    7              0.000026     return shellescape(a:string)
                              endif

FUNCTION  <SNR>78_Unmap()
Called 3 times
Total time:   0.002025
 Self time:   0.001721

count  total (s)   self (s)
    3   0.000486   0.000189   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
   99              0.000085   for map in imaps
   96              0.000610     if maparg(map, "i") =~# '^<Plug>delimitMate'
   42              0.000053       if map == '|'
                                    let map = '<Bar>'
                                  endif
   42              0.000205       exec 'silent! iunmap <buffer> ' . map
   42              0.000025     endif
   96              0.000107   endfor
    3   0.000161   0.000154   silent! doautocmd <nomodeline> User delimitMate_unmap
    3              0.000010   let b:delimitMate_enabled = 0

FUNCTION  SyntaxCheckers_c_gcc_GetLocList()
Called 1 time
Total time:   0.056925
 Self time:   0.000044

count  total (s)   self (s)
    1   0.056924   0.000043     return syntastic#c#GetLocList('c', 'gcc', { 'errorformat':     '%-G%f:%s:,' .     '%-G%f:%l: %#error: %#(Each undeclared identifier is reported only%.%#,' .     '%-G%f:%l: %#error: %#for each function it appears%.%#,' .     '%-GIn file included%.%#,' .     '%-G %#from %f:%l\,,' .     '%f:%l:%c: %trror: %m,' .     '%f:%l:%c: %tarning: %m,' .     '%f:%l:%c: %m,' .     '%f:%l: %trror: %m,' .     '%f:%l: %tarning: %m,'.     '%f:%l: %m', 'main_flags': '-x c -fsyntax-only', 'header_flags': '-x c', 'header_names': '\m\.h$' })

FUNCTION  <SNR>58_show_message()
Called 1 time
Total time:   0.018123
 Self time:   0.018072

count  total (s)   self (s)
                              " The implementation of info() and warn().
    1              0.000003   let nargs = len(a:args)
    1              0.000001   if nargs == 1
                                let message = a:args[0]
                              elseif nargs >= 2
    1   0.000090   0.000039     let args = map(copy(a:args), 's:coerce_argument(v:val)')
    1              0.000005     let message = call('printf', args)
    1              0.000000   endif
    1              0.000002   if exists('message')
    1              0.000001     try
                                  " Temporarily disable Vim's |hit-enter| prompt and mode display.
    1              0.000002       if !exists('s:more_save')
                                    let s:more_save = &more
                                    let s:ruler_save = &ruler
                                    let s:smd_save = &showmode
                                  endif
    1              0.000009       set nomore noshowmode
    1              0.000003       if winnr('$') == 1 | set noruler | endif
    1              0.000003       augroup PluginXoloxHideMode
    1              0.000007         autocmd! CursorHold,CursorHoldI * call s:clear_message()
    1              0.000000       augroup END
    1              0.000022       execute 'echohl' a:hlgroup
                                  " Redraw to avoid the |hit-enter| prompt. We use :silent to avoid issues
                                  " like this one: https://github.com/xolox/vim-easytags/issues/69.
    1              0.017846       silent! redraw
    2              0.000028       for line in split(message, "\n")
    1              0.000034         echomsg line
    1              0.000014       endfor
    1              0.000002       if g:xolox_message_buffer > 0
    1              0.000006         call add(g:xolox_messages, message)
    1              0.000002         if len(g:xolox_messages) > g:xolox_message_buffer
                                      call remove(g:xolox_messages, 0)
                                    endif
    1              0.000001       endif
    1              0.000001     finally
                                  " Always clear message highlighting, even when interrupted by Ctrl-C.
    1              0.000011       echohl none
    1              0.000001     endtry
    1              0.000000   endif

FUNCTION  delimitMate#Get()
Called 108 times
Total time:   0.002102
 Self time:   0.000424

count  total (s)   self (s)
  108   0.002063   0.000385   return call('s:get', a:000)

FUNCTION  xolox#misc#format#timestamp()
Called 1 time
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
                              " Format a time stamp (a string containing a formatted floating point
                              " number) into a human friendly format, for example 70 seconds is phrased as
                              " "1 minute and 10 seconds".
    1              0.000002   let seconds = a:ts + 0
                              " Fast common case with extra precision from reltime().
    1              0.000001   if seconds < 5
                                let extract = matchstr(a:ts, '^\d\+\(\.0*[1-9][1-9]\?\)\?')
                                if extract =~ '[123456789]'
                                  return extract . ' second' . (extract != '1' ? 's' : '')
                                endif
                              endif
                              " Generic but slow code.
    1              0.000001   let result = []
    5              0.000011   for [name, size] in [['day', 60 * 60 * 24], ['hour', 60 * 60], ['minute', 60], ['second', 1]]
    4              0.000004     if seconds >= size
    1              0.000001       let counter = seconds / size
    1              0.000001       let seconds = seconds % size
    1              0.000002       let suffix = counter != 1 ? 's' : ''
    1              0.000009       call add(result, printf('%i %s%s', counter, name, suffix))
    1              0.000001     endif
    4              0.000003   endfor
                              " Format the resulting text?
    1              0.000002   if len(result) == 1
    1              0.000001     return result[0]
                              else
                                return join(result[0:-2], ', ') . ' and ' . result[-1]
                              endif

FUNCTION  <SNR>49_UpdateErrors()
Called 1 time
Total time:   0.098123
 Self time:   0.000208

count  total (s)   self (s)
    1   0.000048   0.000031     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    1   0.000023   0.000011     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    1   0.000021   0.000009     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    1   0.000027   0.000016     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    1   0.000061   0.000012     call s:modemap.synch()
                            
    1   0.000203   0.000011     if s:_skip_file(a:buf)
                                    return
                                endif
                            
    1   0.000212   0.000013     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    1              0.000002     if run_checks
    1   0.059688   0.000025         call s:CacheErrors(a:buf, a:checker_names)
    1   0.000013   0.000006         call syntastic#util#setLastTick(a:buf)
    1              0.000001     elseif a:auto_invoked
                                    return
                                endif
                            
    1   0.000038   0.000014     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    1              0.000003     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    1   0.000016   0.000004     let do_jump = syntastic#util#var('auto_jump') + 0
    1              0.000001     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    1   0.000014   0.000003     if syntastic#util#var('always_populate_loc_list') || do_jump
    1   0.006509   0.000004         call loclist.setloclist(1)
    1              0.000002         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    1              0.000001     endif
                                " }}}3
                            
    1   0.031210   0.000009     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>118__get_cflags()
Called 1 time
Total time:   0.000882
 Self time:   0.000122

count  total (s)   self (s)
                                " determine whether to parse header files as well
    1              0.000012     if has_key(a:opts, 'header_names') && expand('%', 1) =~? a:opts['header_names']
                                    if s:_get_checker_var('g', a:ft, a:ck, 'check_header', 0)
                                        let flags = get(a:opts, 'header_flags', '') . ' -c ' . syntastic#c#NullOutput()
                                    else
                                        " checking headers when check_header is unset: bail out
                                        throw 'Syntastic: skip checks'
                                    endif
                                else
    1              0.000003         let flags = get(a:opts, 'main_flags', '')
    1              0.000001     endif
                            
    1   0.000270   0.000020     let flags .= ' ' . s:_get_checker_var('g', a:ft, a:ck, 'compiler_options', '') . ' ' . s:_get_include_dirs(a:ft)
                            
                                " check if the user manually set some cflags
    1   0.000030   0.000007     let b_cflags = s:_get_checker_var('b', a:ft, a:ck, 'cflags', '')
    1              0.000002     if b_cflags !=# ''
                                    let flags .= ' ' . b_cflags
                                endif
                            
                                " add optional config file parameters
    1   0.000028   0.000009     let config_file = s:_get_checker_var('g', a:ft, a:ck, 'config_file', '.syntastic_' . a:ft . '_config')
    1   0.000434   0.000008     let flags .= ' ' . syntastic#c#ReadConfig(config_file)
                            
    1   0.000032   0.000010     if b_cflags ==# '' && (a:ft ==# 'c' || a:ft ==# 'cpp') && !s:_get_checker_var('g', a:ft, a:ck, 'no_include_search', 0)
                                    " refresh the include file search if desired
    1   0.000026   0.000006         if s:_get_checker_var('g', a:ft, a:ck, 'auto_refresh_includes', 0)
                                        let flags .= ' ' . s:_search_headers()
                                    else
                                        " search for header includes if not cached already
    1              0.000005             if !exists('b:syntastic_' . a:ft . '_includes')
                                            let b:syntastic_{a:ft}_includes = s:_search_headers()
                                        endif
    1              0.000005             let flags .= ' ' . b:syntastic_{a:ft}_includes
    1              0.000001         endif
    1              0.000000     endif
                            
    1              0.000001     return flags

FUNCTION  xolox#misc#str#trim()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " Trim all whitespace from the start and end of a string (the first
                              " argument).
    2              0.000031   return substitute(a:s, '^\_s*\(.\{-}\)\_s*$', '\1', '')

FUNCTION  syntastic#util#shescape()
Called 8 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    8              0.000063     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  <SNR>99__isDebugEnabled_smart()
Called 35 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
   35              0.000105     return and(g:syntastic_debug, a:level)

FUNCTION  xolox#easytags#utils#canonicalize()
Called 7541 times
Total time:   1.253511
 Self time:   0.069704

count  total (s)   self (s)
 7541              0.011595   if !empty(a:pathname)
 7541   1.239032   0.055225     return xolox#misc#path#absolute(xolox#easytags#utils#resolve(a:pathname))
                              endif
                              return a:pathname

FUNCTION  xolox#easytags#utils#resolve()
Called 7542 times
Total time:   0.232445
 Self time:   0.143782

count  total (s)   self (s)
 7542   0.121429   0.032766   if !empty(a:pathname) && xolox#misc#option#get('easytags_resolve_links', 0)
 7542              0.107966     return resolve(a:pathname)
                              endif
                              return a:pathname

FUNCTION  <SNR>78_set()
Called 69 times
Total time:   0.002190
 Self time:   0.000283

count  total (s)   self (s)
   69   0.002176   0.000269   return call('delimitMate#Set', a:000)

FUNCTION  xolox#easytags#filetypes#canonicalize()
Called 3 times
Total time:   0.000157
 Self time:   0.000064

count  total (s)   self (s)
                              " Select a canonical, supported Vim file type given a value of &filetype.
    3   0.000112   0.000019   call s:discover_supported_filetypes()
                              " Split the possibly combined Vim file type into individual file types.
    3              0.000015   for filetype in split(tolower(a:vim_filetype_value), '\.')
                                " Canonicalize the Vim file type.
    3              0.000010     let filetype = get(s:canonical_filetypes, filetype, filetype)
    3              0.000007     if index(s:supported_filetypes, filetype) >= 0
    3              0.000003       return filetype
                                endif
                              endfor
                              return ''

FUNCTION  <SNR>125_filter_merge_tags()
Called 1 time
Total time:  13.274298
 Self time:   0.862272

count  total (s)   self (s)
    1   4.918711   0.032651   let [headers, entries] = xolox#easytags#update#read_tagsfile(a:tagsfile)
    1   0.000406   0.000018   let tagged_files = s:find_tagged_files(a:output, a:cache)
    1              0.000002   if !empty(tagged_files)
    1   3.935336   0.763504     call filter(entries, '!has_key(tagged_files, a:cache.canonicalize(v:val[1]))')
    1              0.000000   endif
                              " Filter tags for non-existing files?
    1              0.000003   let count_before_filter = len(entries)
    1              0.000001   if a:filter_tags
                                call filter(entries, 'a:cache.exists(v:val[1])')
                              endif
    1              0.000003   let num_filtered = count_before_filter - len(entries)
                              " Merge the old and new tags.
    1              0.000003   call extend(entries, a:output)
                              " Now we're ready to save the tags file.
    1   4.419805   0.066059   if !xolox#easytags#update#write_tagsfile(a:tagsfile, headers, entries)
                                let msg = "Failed to write filtered tags file %s!"
                                throw printf(msg, fnamemodify(a:tagsfile, ':~'))
                              endif
    1              0.000003   return num_filtered

FUNCTION  <SNR>49_BufWritePostHook()
Called 1 time
Total time:   0.098349
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000157   0.000015     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000049   0.000024     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
    1   0.098140   0.000017     call s:UpdateErrors(buf, 1, [])

FUNCTION  SyntasticRefreshCursor()
Called 36 times
Total time:   0.154097
 Self time:   0.004260

count  total (s)   self (s)
   36              0.000218     if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
                                    return
                                endif
                            
   36              0.000108     if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
   36              0.000105     let l = line('.')
   36              0.000207     let current_messages = get(b:syntastic_private_messages, l, {})
                            
   36              0.000097     if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
   36              0.000044     if b:syntastic_cursor_columns
   36              0.000116         let c = virtcol('.')
   36              0.000096         if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
   36   0.000974   0.000244         if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
   36              0.000088             let b:syntastic_private_line = l
   36              0.000022         endif
                            
   36              0.000070         if !empty(current_messages)
   15   0.000353   0.000085             let b:syntastic_private_idx = s:_find_index(c, current_messages)
   15   0.148984   0.000145             call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
   15              0.000016         else
   21              0.000035             let b:syntastic_private_idx = -1
   21              0.001118             echo
   21              0.000033         endif
   36              0.000024     else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  xolox#misc#path#join()
Called 7543 times
Total time:   0.120966
 Self time:   0.120966

count  total (s)   self (s)
                              " Join a list of pathname components (the first and only argument) into a
                              " single pathname string. This is the counterpart to the
                              " `xolox#misc#path#split()` function and it expects a list of pathname
                              " components as returned by `xolox#misc#path#split()`.
 7543              0.017935   if type(a:parts) == type([])
 7543              0.006872     if s:windows_compatible
                                  return join(a:parts, xolox#misc#path#directory_separator())
                                elseif get(a:parts, 0) == '/'
                                  " Absolute path on UNIX (non-Windows).
 7543              0.048461       return '/' . join(a:parts[1:], '/')
                                else
                                  " Relative path on UNIX (non-Windows).
                                  return join(a:parts, '/')
                                endif
                              endif
                              return ''

FUNCTION  301()
Called 2 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
   13              0.000042     for match in getmatches()
   11              0.000035         if stridx(match['group'], 'Syntastic') == 0
    9              0.000059             call matchdelete(match['id'])
    9              0.000008         endif
   11              0.000022     endfor

FUNCTION  302()
Called 2 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
    2              0.000033     let newObj = copy(self)
                            
    2              0.000035     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
   11              0.000011     for e in llist
    9              0.000018         if get(e, 'type', '') ==# ''
    1              0.000002             let e['type'] = 'E'
    1              0.000001         endif
    9              0.000003     endfor
                            
    2              0.000004     let newObj._rawLoclist = llist
    2              0.000004     let newObj._name = ''
    2              0.000006     let newObj._owner = bufnr('')
    2              0.000003     let newObj._sorted = 0
    2              0.000004     let newObj._columns = g:syntastic_cursor_columns
                            
    2              0.000002     return newObj

FUNCTION  303()
Called 218 times
Total time:   0.005500
 Self time:   0.004269

count  total (s)   self (s)
  218              0.000879     let buf = a:0 ? a:1 : bufnr('')
  218   0.002554   0.001323     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
  218              0.000824     if type(loclist) != type({}) || empty(loclist)
                                    unlet! loclist
                                    let loclist = g:SyntasticLoclist.New([])
                                endif
  218              0.000196     return loclist

FUNCTION  304()
Called 1 time
Total time:   0.000010
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000009   0.000007     call extend(self._rawLoclist, a:other.copyRaw())

FUNCTION  306()
Called 79 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
   79              0.000177     return empty(self._rawLoclist)

FUNCTION  307()
Called 3 times
Total time:   0.000073
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000006     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    3   0.000060   0.000013     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  308()
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000005     return copy(self._rawLoclist)

FUNCTION  309()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._rawLoclist

FUNCTION  <SNR>44__translate()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009     return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)

FUNCTION  syntastic#util#stamp()
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000043     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  310()
Called 2 times
Total time:   0.000289
 Self time:   0.000067

count  total (s)   self (s)
    2   0.000289   0.000067     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  311()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return self._columns

FUNCTION  315()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     let self._name = a:name

FUNCTION  317()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  318()
Called 1 time
Total time:   0.000164
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000032   0.000017     let self._stamp = syntastic#util#stamp()
    2   0.000123   0.000005     for buf in self.getBuffers()
    1              0.000004         call setbufvar(buf, 'syntastic_loclist', self)
    1              0.000001     endfor

FUNCTION  319()
Called 1 time
Total time:   0.000190
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000179   0.000008     for buf in self.getBuffers()
    1              0.000006         call setbufvar(buf, 'syntastic_loclist', {})
    1              0.000001     endfor

FUNCTION  <SNR>49__ignore_file()
Called 2 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000064     let fname = fnamemodify(a:filename, ':p')
    2              0.000008     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    2              0.000003     return 0

FUNCTION  <SNR>47__normalise_filetype()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000015     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    2              0.000009     let ft = get(g:syntastic_filetype_map, ft, ft)
    2              0.000013     let ft = substitute(ft, '\m-', '_', 'g')
    2              0.000003     return ft

FUNCTION  <SNR>44__set_screen_column()
Called 6 times
Total time:   0.000293
 Self time:   0.000157

count  total (s)   self (s)
    6              0.000011     if !has_key(a:item, 'scol')
    6              0.000013         let col = get(a:item, 'col', 0)
    6              0.000013         if col != 0 && get(a:item, 'vcol', 0) == 0
    6              0.000013             let buf = str2nr(a:item['bufnr'])
    6              0.000006             try
    6              0.000022                 let line = getbufline(buf, a:item['lnum'])[0]
    6              0.000006             catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
    6   0.000179   0.000043             let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
    6              0.000005         else
                                        let a:item['scol'] = col
                                    endif
    6              0.000004     endif

FUNCTION  <SNR>100_OnFileReadyToParse()
Called 36 times
Total time:   0.005505
 Self time:   0.003912

count  total (s)   self (s)
   36   0.001754   0.000161   if s:Pyeval( 'ycm_state.ServerBecomesReady()' )
                                " Server was not ready until now and could not parse previous requests for
                                " the current buffer. We need to send them again.
                                exec s:python_command "ycm_state.OnBufferVisit()"
                                exec s:python_command "ycm_state.OnFileReadyToParse()"
                                " Setting the omnifunc requires us to ask the server if it has a native
                                " semantic completer for the current buffer's filetype. Since we only set it
                                " when entering a buffer or changing the filetype, we try to set it again
                                " now that the server is ready.
                                call s:SetOmnicompleteFunc()
                                return
                              endif
                            
                              " Order is important here; we need to extract any information before
                              " reparsing the file again. If we sent the new parse request first, then
                              " the response would always be pending when we called
                              " HandleFileParseRequest.
   36              0.001874   exec s:python_command "ycm_state.HandleFileParseRequest()"
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one.
   36              0.000171   if b:changedtick != get( b:, 'ycm_changedtick', -1 )
    1              0.000980     exec s:python_command "ycm_state.OnFileReadyToParse()"
    1              0.000004     let b:ycm_changedtick = b:changedtick
    1              0.000001   endif

FUNCTION  <SNR>78_init()
Called 3 times
Total time:   0.004960
 Self time:   0.000924

count  total (s)   self (s)
                            " Initialize variables:
                              " autoclose
    3   0.000205   0.000018   call s:option_init("autoclose", 1)
                              " matchpairs
    3   0.000247   0.000037   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
    3   0.000399   0.000127   call s:option_init("matchpairs_list", map(split(s:get('matchpairs'), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
    3   0.000088   0.000010   let pairs = s:get('matchpairs_list')
    3              0.000032   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                echohl ErrorMsg
                                echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                echohl Normal
                                return 0
                              endif
    3   0.000278   0.000039   call s:option_init("left_delims", map(copy(s:get('matchpairs_list')), 'v:val[0]'))
    3   0.000258   0.000039   call s:option_init("right_delims", map(copy(s:get('matchpairs_list')), 'v:val[1]'))
                              " quotes
    3   0.000151   0.000012   call s:option_init("quotes", "\" ' `")
    3   0.000267   0.000048   call s:option_init("quotes_list",split(s:get('quotes'), '\s\+'))
                              " nesting_quotes
    3   0.000149   0.000012   call s:option_init("nesting_quotes", [])
                              " excluded_regions
    3   0.000171   0.000012   call s:option_init("excluded_regions", "Comment")
    3   0.000235   0.000028   call s:option_init("excluded_regions_list", split(s:get('excluded_regions'), ',\s*'))
    3   0.000084   0.000015   let enabled = len(s:get('excluded_regions_list')) > 0
    3   0.000148   0.000013   call s:option_init("excluded_regions_enabled", enabled)
                              " expand_space
    3              0.000011   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet b:delimitMate_expand_space
                                let b:delimitMate_expand_space = 1
                              endif
    3              0.000011   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet g:delimitMate_expand_space
                                let g:delimitMate_expand_space = 1
                              endif
    3   0.000143   0.000010   call s:option_init("expand_space", 0)
                              " expand_cr
    3              0.000012   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet b:delimitMate_expand_cr
                                let b:delimitMate_expand_cr = 1
                              endif
    3              0.000009   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet g:delimitMate_expand_cr
                                let g:delimitMate_expand_cr = 1
                              endif
    3              0.000025   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
                              endif
    3   0.000160   0.000026   call s:option_init("expand_cr", 0)
                              " expand_in_quotes
    3   0.000143   0.000010   call s:option_init('expand_inside_quotes', 0)
                              " jump_expansion
    3   0.000151   0.000021   call s:option_init("jump_expansion", 0)
                              " smart_matchpairs
    3   0.000151   0.000014   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[£$]\|[^[:punct:][:space:]]\)')
                              " smart_quotes
                              " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
    3   0.000096   0.000022   let quotes = escape(join(s:get('quotes_list'), ''), '\-^[]')
    3              0.000016   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
    3              0.000012   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                if g:delimitMate_smart_quotes
                                  unlet g:delimitMate_smart_quotes
                                else
                                  unlet g:delimitMate_smart_quotes
                                  let g:delimitMate_smart_quotes = ''
                                endif
                              endif
    3              0.000011   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                if b:delimitMate_smart_quotes
                                  unlet b:delimitMate_smart_quotes
                                  if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                    let b:delimitMate_smart_quotes = default_smart_quotes
                                  endif
                                else
                                  unlet b:delimitMate_smart_quotes
                                  let b:delimitMate_smart_quotes = ''
                                endif
                              endif
    3   0.000152   0.000013   call s:option_init("smart_quotes", default_smart_quotes)
                              " apostrophes
    3   0.000164   0.000012   call s:option_init("apostrophes", "")
    3   0.000235   0.000024   call s:option_init("apostrophes_list", split(s:get('apostrophes'), ":\s*"))
                              " tab2exit
    3   0.000153   0.000021   call s:option_init("tab2exit", 1)
                              " balance_matchpairs
    3   0.000141   0.000010   call s:option_init("balance_matchpairs", 0)
                              " eol marker
    3   0.000138   0.000011   call s:option_init("insert_eol_marker", 1)
    3   0.000143   0.000010   call s:option_init("eol_marker", "")
                              " Everything is fine.
    3              0.000003   return 1

FUNCTION  syntastic#util#findFileInParent()
Called 1 time
Total time:   0.000336
 Self time:   0.000336

count  total (s)   self (s)
    1              0.000004     let old_suffixesadd = &suffixesadd
    1              0.000008     let &suffixesadd = ''
    1              0.000315     let file = findfile(a:what, escape(a:where, ' ') . ';')
    1              0.000007     let &suffixesadd = old_suffixesadd
    1              0.000001     return file

FUNCTION  321()
Called 1 time
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    1              0.000002     if !exists('self._cachedBalloons')
    1              0.000013         let sep = has('balloon_multiline') ? "\n" : ' | '
                            
    1              0.000002         let self._cachedBalloons = {}
   10              0.000007         for e in self._rawLoclist
    9              0.000009             let buf = e['bufnr']
                            
    9              0.000016             if !has_key(self._cachedBalloons, buf)
    1              0.000003                 let self._cachedBalloons[buf] = {}
    1              0.000000             endif
                            
    9              0.000022             if has_key(self._cachedBalloons[buf], e['lnum'])
    3              0.000025                 let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
    3              0.000001             else
    6              0.000019                 let self._cachedBalloons[buf][e['lnum']] = e['text']
    6              0.000005             endif
    9              0.000006         endfor
    1              0.000000     endif
                            
    1              0.000003     return get(self._cachedBalloons, bufnr(''), {})

FUNCTION  322()
Called 74 times
Total time:   0.000553
 Self time:   0.000515

count  total (s)   self (s)
   74              0.000186     if !exists('self._cachedErrors')
    1   0.000044   0.000006         let self._cachedErrors = self.filter({'type': 'E'})
    1              0.000000     endif
   74              0.000076     return self._cachedErrors

FUNCTION  323()
Called 74 times
Total time:   0.000520
 Self time:   0.000487

count  total (s)   self (s)
   74              0.000186     if !exists('self._cachedWarnings')
    1   0.000037   0.000004         let self._cachedWarnings = self.filter({'type': 'W'})
    1              0.000001     endif
   74              0.000069     return self._cachedWarnings

FUNCTION  324()
Called 72 times
Total time:   0.000439
 Self time:   0.000253

count  total (s)   self (s)
   72   0.000410   0.000224     return !self.isEmpty()

FUNCTION  325()
Called 1 time
Total time:   0.000965
 Self time:   0.000374

count  total (s)   self (s)
    1              0.000002     if !exists('self._cachedMessages')
    1              0.000002         let self._cachedMessages = {}
                            
    1   0.000018   0.000006         let errors = self.errors() + self.warnings()
   10              0.000009         for e in errors
    9              0.000010             let b = e['bufnr']
    9              0.000009             let l = e['lnum']
                            
    9              0.000019             if !has_key(self._cachedMessages, b)
    1              0.000003                 let self._cachedMessages[b] = {}
    1              0.000000             endif
                            
    9              0.000022             if !has_key(self._cachedMessages[b], l)
    6              0.000013                 let self._cachedMessages[b][l] = [e]
    6              0.000007             elseif self._columns
    3              0.000008                 call add(self._cachedMessages[b][l], e)
    3              0.000003             endif
    9              0.000015         endfor
                            
    1              0.000001         if self._columns
    1              0.000001             if !self._sorted
    2              0.000004                 for b in keys(self._cachedMessages)
    7              0.000010                     for l in keys(self._cachedMessages[b])
    6              0.000010                         if len(self._cachedMessages[b][l]) > 1
    9              0.000011                             for e in self._cachedMessages[b][l]
    6   0.000324   0.000031                                 call s:_set_screen_column(e)
    6              0.000001                             endfor
    3   0.000077   0.000024                             call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
    3              0.000001                         endif
    6              0.000004                     endfor
    1              0.000000                 endfor
    1              0.000001             endif
                            
    2              0.000003             for b in keys(self._cachedMessages)
    7              0.000007                 for l in keys(self._cachedMessages[b])
    6   0.000254   0.000021                     call s:_remove_shadowed_items(self._cachedMessages[b][l])
    6              0.000004                 endfor
    1              0.000001             endfor
    1              0.000001         endif
    1              0.000000     endif
                            
    1              0.000003     return get(self._cachedMessages, a:buf, {})

FUNCTION  327()
Called 2 times
Total time:   0.006533
 Self time:   0.000109

count  total (s)   self (s)
    2              0.000005     if !exists('w:syntastic_loclist_set')
                                    let w:syntastic_loclist_set = []
                                endif
    2              0.000010     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    1              0.000003         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    1   0.000012   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    1   0.006450   0.000039         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    1              0.000000         try
                                        " Vim 7.4.2200 or later
    1              0.000006             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
    1              0.000001         catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
                                    endtry
    1   0.000008   0.000003         call syntastic#util#setLastTick(self._owner)
    1              0.000009         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    1              0.000001     endif

FUNCTION  <SNR>100_OnCursorMovedNormalMode()
Called 36 times
Total time:   0.010167
 Self time:   0.002964

count  total (s)   self (s)
   36   0.001885   0.000187   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   36   0.005650   0.000145   call s:OnFileReadyToParse()
   36              0.002522   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>49__os_name()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000002     return g:_SYNTASTIC_UNAME

FUNCTION  xolox#easytags#update()
Called 1 time
Total time:  13.432401
 Self time:   0.005421

count  total (s)   self (s)
    1   0.000014   0.000003   let async = xolox#misc#option#get('easytags_async', 0)
    1   0.000016   0.000006   call g:xolox#easytags#update_timer.start()
    1              0.000000   try
    1              0.000003     let have_args = !empty(a:filenames)
    1   0.000009   0.000004     let starttime = xolox#misc#timer#start()
    1   0.000097   0.000006     let cfile = s:check_cfile(a:silent, a:filter_tags, have_args)
    1   0.000262   0.000012     let command_line = s:prep_cmdline(cfile, a:filenames)
    1              0.000002     if empty(command_line)
                                  return 0
                                endif
                                " Pack all of the information required to update the tags in
                                " a Vim dictionary which is easy to serialize to a string.
    1              0.000001     let params = {}
    1              0.000003     let params['command'] = command_line
    1              0.000002     let params['ctags_version'] = g:easytags_ctags_version
    1   0.000052   0.000005     let params['default_filetype'] = xolox#easytags#filetypes#canonicalize(&filetype)
    1              0.000002     let params['filter_tags'] = a:filter_tags || async
    1              0.000002     let params['have_args'] = have_args
    1   0.000333   0.000005     let dynamic_tagsfile = xolox#easytags#get_dynamic_tagsfile()
    1              0.000002     if !empty(dynamic_tagsfile)
    1              0.000003       let params['tagsfile'] = dynamic_tagsfile
    1              0.000001     elseif !empty(g:easytags_by_filetype)
                                  let params['directory'] = xolox#misc#path#absolute(g:easytags_by_filetype)
                                  let params['filetypes'] = g:xolox#easytags#filetypes#ctags_to_vim
                                else
                                  let params['tagsfile'] = xolox#easytags#get_global_tagsfile()
                                endif
    1              0.000001     if async
                                  call xolox#misc#async#call({'function': 'xolox#easytags#update#with_vim', 'arguments': [params], 'callback': 'xolox#easytags#async_callback'})
                                else
    1  13.431478   0.005306       call s:report_results(xolox#easytags#update#with_vim(params), 0)
                                  " When :UpdateTags was executed manually we'll refresh the dynamic
                                  " syntax highlighting so that new tags are immediately visible.
    1              0.000004       if !a:silent && xolox#misc#option#get('easytags_auto_highlight', 1)
                                    HighlightTags
                                  endif
    1              0.000001     endif
    1              0.000001     return 1
                              catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
                              finally
    1   0.000084   0.000018     call g:xolox#easytags#update_timer.stop()
    1              0.000001   endtry

FUNCTION  xolox#misc#perm#set()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
                              " Set the permissions (the second argument) of the pathname given as the
                              " first argument. Expects a permissions value created by
                              " `xolox#misc#perm#get()`.
    1              0.000003   if !empty(a:perms)
                                let pathname = xolox#misc#path#absolute(a:fname)
                                let [owner, group, mode] = a:perms
                                if s:run('chown %s:%s %s', owner, group, pathname) && s:run('chmod %s %s', mode, pathname)
                                  call xolox#misc#msg#debug("vim-misc %s: Successfully set %s owner to %s, group to %s and permissions to %s.", g:xolox#misc#version, pathname, owner, group, mode)
                                  return 1
                                endif
                              endif
    1              0.000001   return 0

FUNCTION  330()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000005     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    1              0.000011         let self._mode = 'active'
    1              0.000009         let self._activeFiletypes = []
    1              0.000006         let self._passiveFiletypes = []
    1              0.000001     endif

FUNCTION  331()
Called 1 time
Total time:   0.000170
 Self time:   0.000064

count  total (s)   self (s)
    1   0.000034   0.000012     let registry = g:SyntasticRegistry.Instance()
    1   0.000074   0.000011     let fts = registry.resolveFiletypes(a:filetype)
                            
    1   0.000029   0.000024     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    1   0.000026   0.000010         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  332()
Called 1 time
Total time:   0.000199
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000006     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    1              0.000004     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    1   0.000184   0.000014     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  333()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return self._mode ==# 'passive'

FUNCTION  338()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000016     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  xolox#easytags#ctags_command()
Called 1 time
Total time:   0.000040
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000014   0.000004   let program = xolox#misc#option#get('easytags_cmd')
    1              0.000001   if !empty(program)
    1   0.000014   0.000002     let options = xolox#misc#option#get('easytags_opts')
    1              0.000002     if !empty(options)
                                  let command_line = [program]
                                  call extend(command_line, map(copy(options), 'xolox#misc#escape#shell(expand(v:val))'))
                                  let program = join(command_line)
                                endif
    1              0.000001     return program
                              endif
                              return ''

FUNCTION  340()
Called 1 time
Total time:   0.031201
 Self time:   0.000270

count  total (s)   self (s)
    1   0.000055   0.000012     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    1   0.000011   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
    6              0.000007     for type in self._enabled_types
    5              0.000033         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000115   0.000042         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    5              0.000016             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    2              0.000006                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    2   0.000058   0.000009                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    2   0.023620   0.000009                     call self._notifier[type].refresh(a:loclist)
    2   0.000042   0.000012                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    2              0.000001                 endif
    2              0.000000             else
    3   0.007136   0.000018                 call self._notifier[type].refresh(a:loclist)
    3              0.000003             endif
    5              0.000002         endif
    5              0.000022     endfor

FUNCTION  341()
Called 1 time
Total time:   0.000646
 Self time:   0.000275

count  total (s)   self (s)
    1   0.000021   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
    6              0.000012     for type in self._enabled_types
    5              0.000051         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
    5              0.000035         if has_key(g:{class}, 'reset')
    3   0.000381   0.000025             call self._notifier[type].reset(a:loclist)
    3              0.000002         endif
                            
                                    " also reset stamps
    5              0.000026         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    2              0.000040             let b:syntastic_private_{type}_stamp = []
    2              0.000002         endif
    5              0.000022     endfor

FUNCTION  343()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000010     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
    1              0.000003     return s:SyntasticRegistryInstance

FUNCTION  345()
Called 1 time
Total time:   0.000301
 Self time:   0.000134

count  total (s)   self (s)
    1   0.000037   0.000006     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    1              0.000007     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    1              0.000002     let cnames = []
    1              0.000002     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
    2              0.000003         for ft in ftlist
    1   0.000035   0.000006             call self._sanityCheck(ft)
    1              0.000010             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    1              0.000013             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    1              0.000002         endfor
    1              0.000001     endif
    1   0.000038   0.000006     let cnames = syntastic#util#unique(cnames)
                            
    2   0.000044   0.000016     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    1   0.000011   0.000005         call self._loadCheckersFor(ft, 0)
    1              0.000014     endfor
                            
    1   0.000047   0.000006     return self._filterCheckersByName(cnames)

FUNCTION  syntastic#util#redraw()
Called 15 times
Total time:   0.147394
 Self time:   0.147394

count  total (s)   self (s)
   15              0.000030     if a:full
                                    redraw!
                                else
   15              0.147270         redraw
   15              0.000039     endif

FUNCTION  <SNR>118__get_include_dirs()
Called 1 time
Total time:   0.000221
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000002     let include_dirs = []
                            
    1              0.000013     if a:filetype =~# '\v^%(c|cpp|objc|objcpp)$' && (!exists('g:syntastic_'.a:filetype.'_no_default_include_dirs') || !g:syntastic_{a:filetype}_no_default_include_dirs)
    1              0.000005         let include_dirs = copy(s:default_includes)
    1              0.000001     endif
                            
    1              0.000004     if exists('g:syntastic_'.a:filetype.'_include_dirs')
                                    call extend(include_dirs, g:syntastic_{a:filetype}_include_dirs)
                                endif
                            
    1   0.000190   0.000052     return join(map(syntastic#util#unique(include_dirs), 'syntastic#util#shescape("-I" . v:val)'))

FUNCTION  <SNR>55_select_tags_file()
Called 1 time
Total time:   0.000166
 Self time:   0.000035

count  total (s)   self (s)
                              " If the selected tags file exists, make sure its writable. Also provide the
                              " user with feedback about the tags file selection process.
    1              0.000014   if filereadable(a:tagsfile) && filewritable(a:tagsfile) != 1
                                let message = "The %s tags file %s isn't writable!"
                                throw printf(message, a:kind, fnamemodify(a:tagsfile, ':~'))
                              endif
                              " Provide the user with feedback about the tags file selection process.
    1   0.000017   0.000008   call xolox#misc#msg#debug("easytags.vim %s: Selected %s tags file %s.", g:xolox#easytags#version, a:kind, a:tagsfile)
                              " Canonicalize the tags file's pathname.
    1   0.000128   0.000006   return xolox#misc#path#absolute(a:tagsfile)

FUNCTION  <SNR>38_FileUpdate()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005     if g:NERDTreeUpdateOnWrite != 1
    1              0.000002         return
                                endif
                            
                                if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                call g:NERDTree.CursorToTreeWin()
                                let l:node = b:NERDTree.root.findNode(g:NERDTreePath.New(a:fname))
                                if l:node == {}
                                    return
                                endif
                                call l:node.refreshFlags()
                                let l:node = l:node.parent
                                while !empty(l:node)
                                    call l:node.refreshDirFlags()
                                    let l:node = l:node.parent
                                endwhile
                            
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  350()
Called 2 times
Total time:   0.000094
 Self time:   0.000051

count  total (s)   self (s)
    2   0.000093   0.000050     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  353()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000004     let sep_idx = stridx(a:cname, '/')
    1              0.000001     if sep_idx > 0
    1              0.000004         let ft = a:cname[: sep_idx-1]
    1              0.000003         let name = a:cname[sep_idx+1 :]
    1              0.000001     else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
    1              0.000007     return get(self._checkerMap[ft], name, {})

FUNCTION  355()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004     if !a:force && has_key(self._checkerMap, a:filetype)
    1              0.000001         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  356()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000008     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
    1              0.000007     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  359()
Called 1 time
Total time:   0.023315
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000009   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    1   0.000012   0.000004     let old_signs = copy(self._bufSignIds())
    1   0.000017   0.000003     if self.enabled()
    1              0.000001         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
    1   0.011791   0.000010         call self._signErrors(a:loclist)
    1              0.000000     endif
    1   0.011477   0.000006     call self._removeSigns(old_signs)

FUNCTION  <SNR>55_prep_cmdline()
Called 1 time
Total time:   0.000250
 Self time:   0.000102

count  total (s)   self (s)
    1   0.000053   0.000005   let vim_file_type = xolox#easytags#filetypes#canonicalize(&filetype)
    1   0.000017   0.000004   let custom_languages = xolox#misc#option#get('easytags_languages', {})
    1              0.000003   let language = get(custom_languages, vim_file_type, {})
    1              0.000001   if empty(language)
    1   0.000045   0.000005     let cmdline = [xolox#easytags#ctags_command()]
    1              0.000002     call add(cmdline, '--fields=+l')
    1              0.000002     call add(cmdline, '--c-kinds=+p')
    1              0.000001     call add(cmdline, '--c++-kinds=+p')
    1              0.000001     call add(cmdline, '--sort=no')
    1              0.000002     call add(cmdline, '-f-')
    1   0.000014   0.000003     if xolox#misc#option#get('easytags_include_members', 0)
    1              0.000002       call add(cmdline, '--extra=+q')
    1              0.000001     endif
    1              0.000000   else
                                let program = get(language, 'cmd', xolox#easytags#ctags_command())
                                if empty(program)
                                  call xolox#misc#msg#warn("easytags.vim %s: No 'cmd' defined for language '%s', and also no global default!", g:xolox#easytags#version, vim_file_type)
                                  return ''
                                endif
                                let cmdline = [program] + get(language, 'args', [])
                                call add(cmdline, xolox#misc#escape#shell(get(language, 'stdout_opt', '-f-')))
                              endif
    1              0.000001   let have_args = 0
    1              0.000001   if a:cfile != ''
    1   0.000014   0.000003     if xolox#misc#option#get('easytags_autorecurse', 0)
    1              0.000004       call add(cmdline, empty(language) ? '-R' : xolox#misc#escape#shell(get(language, 'recurse_flag', '-R')))
    1   0.000031   0.000006       call add(cmdline, xolox#misc#escape#shell(a:cfile))
    1              0.000001     else
                                  if empty(language)
                                    " TODO Should --language-force distinguish between C and C++?
                                    " TODO --language-force doesn't make sense for JavaScript tags in HTML files?
                                    let filetype = xolox#easytags#filetypes#to_ctags(vim_file_type)
                                    call add(cmdline, xolox#misc#escape#shell('--language-force=' . filetype))
                                  endif
                                  call add(cmdline, xolox#misc#escape#shell(a:cfile))
                                endif
    1              0.000001     let have_args = 1
    1              0.000000   else
                                for arg in a:arguments
                                  if arg =~ '^-'
                                    call add(cmdline, arg)
                                    let have_args = 1
                                  else
                                    let matches = split(expand(arg), "\n")
                                    if !empty(matches)
                                      call map(matches, 'xolox#misc#escape#shell(xolox#easytags#utils#canonicalize(v:val))')
                                      call extend(cmdline, matches)
                                      let have_args = 1
                                    endif
                                  endif
                                endfor
                              endif
                              " No need to run Exuberant Ctags without any filename arguments!
    1              0.000012   return have_args ? join(cmdline) : ''

FUNCTION  xolox#easytags#update#parse_entries()
Called 1 time
Total time:   0.000289
 Self time:   0.000256

count  total (s)   self (s)
    1   0.000281   0.000248   call map(a:lines, 'xolox#easytags#update#parse_entry(v:val)')
    1              0.000007   return filter(a:lines, '!empty(v:val)')

FUNCTION  xolox#misc#timer#start()
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                              " Start a timer. This returns a list which can later be passed to
                              " `xolox#misc#timer#stop()`.
    3              0.000018   return [s:unique_marker, s:has_reltime ? reltime() : localtime()]

FUNCTION  361()
Called 1 time
Total time:   0.011781
 Self time:   0.011640

count  total (s)   self (s)
    1              0.000002     let loclist = a:loclist
    1   0.000005   0.000004     if !loclist.isEmpty()
                            
    1              0.000001         let buf = bufnr('')
    1              0.000001         if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
    1   0.000052   0.000004         let issues = copy(loclist.errors())
    1   0.000055   0.000013         call extend(issues, loclist.warnings())
    1              0.000008         call filter(issues, 'v:val["bufnr"] == buf')
    1              0.000001         let seen = {}
                            
   10              0.000008         for i in issues
    9              0.000030             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
    6              0.000015                 let seen[i['lnum']] = 1
                            
    6              0.000014                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
    6              0.000014                 let sign_subtype = get(i, 'subtype', '')
    6              0.000017                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
    6              0.011326                 execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
    6   0.000140   0.000090                 call add(self._bufSignIds(), s:next_sign_id)
    6              0.000013                 let s:next_sign_id += 1
    6              0.000003             endif
    9              0.000007         endfor
    1              0.000000     endif

FUNCTION  362()
Called 1 time
Total time:   0.011471
 Self time:   0.011388

count  total (s)   self (s)
    1              0.000004     if has('signs')
    7              0.000012         for s in reverse(copy(a:ids))
    6              0.011244             execute 'sign unplace ' . s
    6   0.000197   0.000114             call remove(self._bufSignIds(), index(self._bufSignIds(), s))
    6              0.000005         endfor
    1              0.000000     endif

FUNCTION  363()
Called 19 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   19              0.000066     if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
   19              0.000027     return b:syntastic_private_sign_ids

FUNCTION  364()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000001     if s:has_reltime
    1              0.000005       let self.current = reltime()
    1              0.000001     else
                                  let self.current = localtime()
                                endif

FUNCTION  365()
Called 1 time
Total time:   0.000066
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000005     if empty(get(self, 'current'))
                                  throw "timer.stop() called on a timer that was never started!"
                                endif
    1              0.000002     if s:has_reltime
    1   0.000029   0.000013       let elapsed_time_string = xolox#misc#str#trim(reltimestr(reltime(self.current)))
                                  " This is a bit silly (converting to a string and then parsing that) but
                                  " the value of reltime() is documented as being platform specific...
    1              0.000006       let [seconds, microseconds] = split(elapsed_time_string, '\.')
    1              0.000008       let self.total[0] += substitute(seconds, '^0*', '', '')
    1              0.000004       let self.total[1] += substitute(microseconds, '^0*', '', '')
    1              0.000003       let self.current = []
    1              0.000001     else
                                  let self.total[0] += localtime() - self.current
                                  let self.current = 0
                                endif

FUNCTION  <SNR>49_ClearCache()
Called 1 time
Total time:   0.000912
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000060   0.000011     let loclist = g:SyntasticLoclist.current(a:buf)
    1   0.000654   0.000008     call s:notifiers.reset(loclist)
    1   0.000197   0.000007     call loclist.destroy()

FUNCTION  <SNR>89_Highlight_Matching_Pair()
Called 37 times
Total time:   0.013952
 Self time:   0.013952

count  total (s)   self (s)
                              " Remove any previous match.
   37              0.000141   if exists('w:paren_hl_on') && w:paren_hl_on
   14              0.000058     silent! call matchdelete(3)
   14              0.000036     let w:paren_hl_on = 0
   14              0.000017   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   37              0.000183   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   37              0.000119   let c_lnum = line('.')
   37              0.000087   let c_col = col('.')
   37              0.000043   let before = 0
                            
   37              0.000110   let text = getline(c_lnum)
   37              0.000723   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   37              0.000098   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   37              0.000177     let [c_before, c] = matches[1:2]
   37              0.000026   endif
   37              0.000344   let plist = split(&matchpairs, '.\zs[:,]')
   37              0.000126   let i = index(plist, c)
   37              0.000044   if i < 0
                                " not found, in Insert mode try character before the cursor
   24              0.000111     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
   24              0.000021     if i < 0
                                  " not found, nothing to do
   24              0.000021       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
   13              0.000017   if i % 2 == 0
    1              0.000001     let s_flags = 'nW'
    1              0.000002     let c2 = plist[i + 1]
    1              0.000001   else
   12              0.000017     let s_flags = 'nbW'
   12              0.000017     let c2 = c
   12              0.000034     let c = plist[i - 1]
   12              0.000008   endif
   13              0.000021   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   13              0.000015   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   13              0.000053   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
   13              0.002286   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   13              0.000041   let stoplinebottom = line('w$')
   13              0.000034   let stoplinetop = line('w0')
   13              0.000017   if i % 2 == 0
    1              0.000002     let stopline = stoplinebottom
    1              0.000001   else
   12              0.000030     let stopline = stoplinetop
   12              0.000009   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   13              0.000046   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
   13              0.000061     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   13              0.000009   endif
   13              0.000012   try
   13              0.006265     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   13              0.000019   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   13              0.000015   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
   13              0.000033   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   13              0.000039     if exists('*matchaddpos')
   13              0.000180       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   13              0.000010     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   13              0.000023     let w:paren_hl_on = 1
   13              0.000008   endif

FUNCTION  xolox#misc#path#absolute()
Called 7543 times
Total time:   0.951691
 Self time:   0.512115

count  total (s)   self (s)
                              " Canonicalize and resolve a pathname, *regardless of whether it exists*.
                              " This is intended to support string comparison to determine whether two
                              " pathnames point to the same directory or file.
 7543              0.018166   if type(a:path) == type('')
 7543              0.009424     let path = a:path
                                " Make the pathname absolute.
 7543              0.017090     if path =~ '^\~'
                                  " Expand ~ to $HOME.
                                  let path = $HOME . '/' . path[1:]
                                elseif xolox#misc#path#is_relative(path)
                                  " Make relative pathnames absolute.
                                  let path = getcwd() . '/' . path
                                endif
                                " Resolve symbolic links to find the canonical pathname. In my tests this
                                " also removes all symbolic pathname segments (`.' and `..'), even when
                                " the pathname does not exist. Also there used to be a bug in resolve()
                                " where it wouldn't resolve pathnames ending in a directory separator.
                                " Since it's not much trouble to work around, that's what we do.
 7543              0.148062     let path = resolve(substitute(path, s:windows_compatible ? '[\/]\+$' : '/\+$', '', ''))
                                " Normalize directory separators (especially relevant on Windows).
 7543   0.335273   0.085800     let parts = xolox#misc#path#split(path)
 7543              0.010811     if s:windows_compatible && parts[0] =~ '^[\/][\/]'
                                  " Also normalize the two leading "directory separators" (I'm not
                                  " sure what else to call them :-) in Windows UNC pathnames.
                                  let parts[0] = repeat(xolox#misc#path#directory_separator(), 2) . parts[0][2:]
                                elseif s:windows_compatible && parts[0] =~ '^[\/]$'
                                  " If a pathname is relative to the current drive we should add
                                  " the drive letter in order to make the pathname absolute.
                                  let parts[0] = matchstr(getcwd(), '^\a:')
                                endif
 7543   0.200767   0.079801     return xolox#misc#path#join(parts)
                              endif
                              return ''

FUNCTION  <SNR>121_Init()
Called 37 times
Total time:   0.000967
 Self time:   0.000967

count  total (s)   self (s)
   37              0.000060     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
   37              0.000042     if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
   37              0.000037     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
   37              0.000040     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
   37              0.000030     return 1

FUNCTION  <SNR>121_HandleBufWrite()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005     if index(s:delayed_update_files, a:fname) == -1
                                    call add(s:delayed_update_files, a:fname)
                                endif

FUNCTION  syntastic#util#system()
Called 1 time
Total time:   0.044135
 Self time:   0.000481

count  total (s)   self (s)
    1              0.000002     let old_shell = &shell
    1              0.000004     let old_lc_messages = $LC_MESSAGES
    1              0.000003     let old_lc_all = $LC_ALL
                            
    1   0.000028   0.000007     let &shell = syntastic#util#var('shell')
    1              0.000005     let $LC_MESSAGES = 'C'
    1              0.000002     let $LC_ALL = ''
                            
    1              0.000002     let crashed = 0
    1              0.000003     let cmd_start = reltime()
    1              0.000001     try
    1   0.043881   0.000277         let out = system(a:command)
    1              0.000009     catch
                                    let crashed = 1
                                    call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                    let out = ''
                                endtry
    1              0.000047     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
    1              0.000009     let $LC_ALL = old_lc_all
    1              0.000003     let $LC_MESSAGES = old_lc_messages
                            
    1              0.000013     let &shell = old_shell
                            
    1              0.000007     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
    1   0.000046   0.000017         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
    1              0.000002     endif
                            
    1              0.000004     return out

FUNCTION  <SNR>49__skip_file()
Called 2 times
Total time:   0.000305
 Self time:   0.000167

count  total (s)   self (s)
    2              0.000009     let fname = bufname(a:buf)
    2   0.000277   0.000139     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    2              0.000003     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    2              0.000003     return skip

FUNCTION  syntastic#log#debugShowVariables()
Called 2 times
Total time:   0.000027
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000022   0.000014     if !s:_isDebugEnabled(a:level)
    2              0.000002         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>122_discover_supported_filetypes()
Called 3 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
                              " Initialize predefined groups & mappings and discover supported file types.
    3              0.000004   if !s:discovered_filetypes
                                " Discover the file types supported by Exuberant Ctags?
                                let command_line = xolox#easytags#ctags_command()
                                if !empty(command_line)
                                  let starttime = xolox#misc#timer#start()
                                  let command_line .= ' --list-languages'
                                  for line in xolox#misc#os#exec({'command': command_line})['stdout']
                                    if line =~ '\[disabled\]$'
                                      " Ignore languages that have been explicitly disabled using `--languages=-Vim'.
                                      continue
                                    elseif line =~ '^\w\S*$'
                                      call add(s:supported_filetypes, xolox#easytags#filetypes#to_vim(xolox#misc#str#trim(line)))
                                    elseif line =~ '\S'
                                      call xolox#misc#msg#warn("easytags.vim %s: Failed to parse line of output from ctags --list-languages: %s", g:xolox#easytags#version, string(line))
                                    endif
                                  endfor
                                  let msg = "easytags.vim %s: Retrieved %i supported languages in %s."
                                  call xolox#misc#timer#stop(msg, g:xolox#easytags#version, len(s:supported_filetypes), starttime)
                                endif
                                " Add file types supported by language specific programs.
                                call extend(s:supported_filetypes, keys(xolox#misc#option#get('easytags_languages', {})))
                                " Don't run s:discover_supported_filetypes() more than once.
                                let s:discovered_filetypes = 1
                              endif

FUNCTION  xolox#misc#timer#stop()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [verbose] option to one
                              " (1) or higher.
                              "
                              " This function has the same argument handling as Vim's [printf()] [printf]
                              " function with one difference: At the point where you want the elapsed time
                              " to be embedded, you write `%s` and you pass the list returned by
                              " `xolox#misc#timer#start()` as an argument.
                              "
                              " [verbose]: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
                              " [printf]: http://vimdoc.sourceforge.net/htmldoc/eval.html#printf()
    1              0.000003   if (g:timer_enabled || &verbose >= g:timer_verbosity)
                                call call('xolox#misc#msg#info', map(copy(a:000), 'xolox#misc#timer#convert(v:val)'))
                              endif

FUNCTION  <SNR>55_check_cfile()
Called 1 time
Total time:   0.000091
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000001   if a:have_args
                                return ''
                              endif
    1              0.000002   let silent = a:silent || a:filter_tags
    1   0.000015   0.000003   if xolox#misc#option#get('easytags_autorecurse', 0)
    1   0.000063   0.000027     let cdir = xolox#easytags#utils#resolve(expand('%:p:h'))
    1              0.000004     if !isdirectory(cdir)
                                  if silent | return '' | endif
                                  throw "The directory of the current file doesn't exist yet!"
                                endif
    1              0.000001     return cdir
                              endif
                              let cfile = xolox#easytags#utils#resolve(expand('%:p'))
                              if cfile == '' || !filereadable(cfile)
                                if silent | return '' | endif
                                throw "You'll need to save your file before using :UpdateTags!"
                              elseif g:easytags_ignored_filetypes != '' && &ft =~ g:easytags_ignored_filetypes
                                if silent | return '' | endif
                                throw "The " . string(&ft) . " file type is explicitly ignored."
                              elseif empty(xolox#easytags#filetypes#canonicalize(&ft))
                                if silent | return '' | endif
                                throw "Exuberant Ctags doesn't support the " . string(&ft) . " file type!"
                              endif
                              return cfile

FUNCTION  <SNR>121_IsValidFile()
Called 3 times
Total time:   0.000062
 Self time:   0.000032

count  total (s)   self (s)
    3   0.000027   0.000011     call s:debug('Checking if file is valid [' . a:fname . ']')
                            
    3              0.000005     if a:fname == '' || a:ftype == ''
    3   0.000021   0.000007         call s:debug('Empty filename or type')
    3              0.000002         return 0
                                endif
                            
                                if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
                                    call s:debug('File not readable')
                                    return 0
                                endif
                            
                                if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call s:debug('File is marked as ignored')
                                    return 0
                                endif
                            
                                let winnr = bufwinnr(a:fname)
                                if winnr != -1 && getwinvar(winnr, '&diff')
                                    call s:debug('Window is in diff mode')
                                    return 0
                                endif
                            
                                if &previewwindow
                                    call s:debug('In preview window')
                                    return 0
                                endif
                            
                                if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call s:debug('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
                                return 1

FUNCTION  syntastic#util#getbufvar()
Called 218 times
Total time:   0.001231
 Self time:   0.001231

count  total (s)   self (s)
  218              0.001128     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  <SNR>57_unescape_tags()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000010   return substitute(a:s, '\\\([\\, ]\)', '\1', 'g')

FUNCTION  syntastic#util#isRunningWindows()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000011     return has('win16') || has('win32') || has('win64')

FUNCTION  xolox#misc#os#can_use_dll()
Called 2 times
Total time:   0.000591
 Self time:   0.000591

count  total (s)   self (s)
                              " If a) we're on Microsoft Windows, b) the vim-shell plug-in is installed
                              " and c) the compiled DLL included in vim-shell works, we can use the
                              " vim-shell plug-in to execute external commands! Returns 1 (true)
                              " if we can use the DLL, 0 (false) otherwise.
    2              0.000002   let can_use_dll = 0
    2              0.000002   try
    2              0.000557     let can_use_dll = xolox#shell#can_use_dll()
                              catch /^Vim\%((\a\+)\)\=:E117/
                                " Silence E117.
    2              0.000005   endtry
    2              0.000002   return can_use_dll

FUNCTION  xolox#misc#msg#debug()
Called 8 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
    8              0.000027   if &vbs >= 1
                                call s:show_message('Question', a:000)
                              endif

FUNCTION  <SNR>121_debug()
Called 15 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
   15              0.000011     if s:debug
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  syntastic#util#var()
Called 20 times
Total time:   0.000285
 Self time:   0.000167

count  total (s)   self (s)
   20   0.000276   0.000158     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  xolox#misc#perm#update()
Called 1 time
Total time:   1.881105
 Self time:   1.865045

count  total (s)   self (s)
                              " Atomically update a file's contents while preserving the owner, group and
                              " mode. The first argument is the pathname of the file to update (a string).
                              " The second argument is the list of lines to be written to the file. Writes
                              " the new contents to a temporary file and renames the temporary file into
                              " place, thereby preventing readers from reading a partially written file.
                              " Returns 1 if the file is successfully updated, 0 otherwise.
                              "
                              " Note that if `xolox#misc#perm#get()` and `xolox#misc#perm#set()` cannot be
                              " used to preserve the file owner/group/mode the file is still updated using
                              " a rename (for compatibility with non-UNIX systems and incompatible
                              " `/usr/bin/stat` implementations) so in that case you can still lose the
                              " file's owner/group/mode.
    1   0.000023   0.000011   let starttime = xolox#misc#timer#start()
    1              0.000005   let temporary_file = printf('%s.tmp', a:fname)
    1   0.000029   0.000009   call xolox#misc#msg#debug("vim-misc %s: Writing new contents of %s to temporary file %s ..", g:xolox#misc#version, a:fname, temporary_file)
    1              1.861590   if writefile(a:contents, temporary_file) == 0
    1   0.016039   0.000043     call xolox#misc#perm#set(temporary_file, xolox#misc#perm#get(a:fname))
    1   0.000044   0.000027     call xolox#misc#msg#debug("vim-misc %s: Replacing %s with %s ..", g:xolox#misc#version, a:fname, temporary_file)
    1              0.003311     if rename(temporary_file, a:fname) == 0
    1   0.000045   0.000030       call xolox#misc#timer#stop("vim-misc %s: Successfully updated %s using atomic rename in %s.", g:xolox#misc#version, a:fname, starttime)
    1              0.000004       return 1
                                endif
                              endif
                              if filereadable(temporary_file)
                                call delete(temporary_file)
                              endif
                              return 0

FUNCTION  syntastic#util#compareLexi()
Called 3 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    3              0.000015     for idx in range(max([len(a:a), len(a:b)]))
    3              0.000011         let a_element = str2nr(get(a:a, idx, 0))
    3              0.000008         let b_element = str2nr(get(a:b, idx, 0))
    3              0.000003         if a_element != b_element
    3              0.000004             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  Update_header_42()
Called 1 time
Total time:   0.026871
 Self time:   0.000278

count  total (s)   self (s)
    1   0.013914   0.000185 	let s:author = system("echo $USER42 | tr -d '\n'")
    1              0.000010 	let l:pattern = "/*   Updated:"
    1              0.000010 	let l:line = getline(9)
    1              0.000022 	if match(l:line, l:pattern) != -1
    1   0.012899   0.000035 		call Insert_header_42_add_info("Updated", "###   ########.fr       */", 9, 1)
    1              0.000003 	endif
    1              0.000006 	unlet s:author

FUNCTION  <SNR>55_report_results()
Called 1 time
Total time:   0.018252
 Self time:   0.000074

count  total (s)   self (s)
    1   0.000039   0.000015   if !xolox#misc#option#get('easytags_suppress_report', 0)
    1              0.000003     let actions = []
    1              0.000002     if a:response['num_updated'] > 0
    1              0.000008       call add(actions, printf('updated %i tags', a:response['num_updated']))
    1              0.000001     endif
    1              0.000001     if a:response['num_filtered'] > 0
                                  call add(actions, printf('filtered %i invalid tags', a:response['num_filtered']))
                                endif
    1              0.000002     if !empty(actions)
    1              0.000002       let function = a:async ? 'xolox#misc#msg#debug' : 'xolox#misc#msg#info'
    1   0.000017   0.000007       let actions_string = xolox#misc#str#ucfirst(join(actions, ' and '))
    1              0.000002       let command_type = a:async ? 'asynchronously' : 'synchronously'
    1   0.018165   0.000021       call call(function, ["easytags.vim %s: %s in %s (%s).", g:xolox#easytags#version, actions_string, a:response['elapsed_time'], command_type])
    1              0.000001     endif
    1              0.000000   endif

FUNCTION  syntastic#c#GetLocList()
Called 1 time
Total time:   0.056881
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000001     try
    1   0.000893   0.000011         let flags = s:_get_cflags(a:filetype, a:subchecker, a:options)
    1              0.000001     catch /\m\C^Syntastic: skip checks$/
                                    return []
                                endtry
                            
    1   0.000050   0.000013     let makeprg = syntastic#util#shexpand(g:syntastic_{a:filetype}_compiler) . ' ' . flags . ' ' . syntastic#util#shexpand('%')
                            
    1   0.000029   0.000008     let errorformat = s:_get_checker_var('g', a:filetype, a:subchecker, 'errorformat', a:options['errorformat'])
                            
    1   0.000027   0.000007     let postprocess = s:_get_checker_var('g', a:filetype, a:subchecker, 'remove_include_errors', 0) ? ['filterForeignErrors'] : []
                            
                                " process makeprg
    1   0.055871   0.000029     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'postprocess': postprocess })

FUNCTION  xolox#easytags#update#write_tagsfile()
Called 1 time
Total time:   4.353746
 Self time:   0.129015

count  total (s)   self (s)
                              " This function always sorts the tags file but understands "foldcase".
    1              0.000002   let sort_order = 0
    1              0.000001   let sort_header_present = 0
    1              0.000002   let sort_header_pattern = '^!_TAG_FILE_SORTED\t\zs\d'
                              " Discover the sort order defined in the tags file headers.
    1              0.000010   let i = 0
    7              0.000008   for line in a:headers
    6              0.000032     let match = matchstr(line, sort_header_pattern)
    6              0.000009     if !empty(match)
    1              0.000001       let sort_header_present = 1
    1              0.000002       let sort_order = match + 0
    1              0.000001       if sort_order == 0
                                    let sort_order = 2
                                    let a:headers[i] = substitute(line, sort_header_pattern, '2', '')
                                  endif
    1              0.000001     endif
    6              0.000011   endfor
    1              0.000001   if !sort_header_present
                                " If no sorting is defined in the tags file headers we default to
                                " "foldcase" sorting and add the header.
                                let sort_order = 2
                                call add(a:headers, "!_TAG_FILE_SORTED\t2\t/0=unsorted, 1=sorted, 2=foldcase/")
                              endif
    1   2.343619   0.000010   call xolox#easytags#update#join_entries(a:entries)
    1              0.000006   if sort_order == 1
    1              0.062236     call sort(a:entries)
    1              0.000005   else
                                call sort(a:entries, function('xolox#easytags#update#foldcase_compare'))
                              endif
    1              0.000004   let lines = []
    1   0.000029   0.000012   if xolox#misc#os#is_win()
                                " Exuberant Ctags on Windows requires \r\n but Vim's writefile() doesn't add them!
                                for line in a:headers
                                  call add(lines, line . "\r")
                                endfor
                                for line in a:entries
                                  call add(lines, line . "\r")
                                endfor
                              else
    1              0.000005     call extend(lines, a:headers)
    1              0.066486     call extend(lines, a:entries)
    1              0.000007   endif
                              " Make sure the directory exists.
    1              0.000016   let directory = fnamemodify(a:tagsfile, ':h')
    1              0.000022   if !isdirectory(directory)
                                call mkdir(directory, 'p')
                              endif
                              " Write the new contents to a temporary file and atomically rename the
                              " temporary file into place while preserving the file's permissions.
    1   1.881140   0.000035   return xolox#misc#perm#update(a:tagsfile, lines)

FUNCTION  <SNR>54_readfile()
Called 4 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    4              0.000006   try
    4              0.000100     return readfile(a:fname)
                              catch
                                call xolox#misc#msg#warn("vim-misc %s: Failed to read temporary file (%s) with %s of external command: %s! (external command: %s)", g:xolox#misc#version, a:fname, a:label, v:exception, a:cmd)
                                return []
                              endtry

FUNCTION  <SNR>10_LoadIndent()
Called 3 times
Total time:   0.000838
 Self time:   0.000838

count  total (s)   self (s)
    3              0.000009     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    3              0.000008     let s = expand("<amatch>")
    3              0.000005     if s != ""
    3              0.000005       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    6              0.000018       for name in split(s, '\.')
    3              0.000753 	exe 'runtime! indent/' . name . '.vim'
    3              0.000003       endfor
    3              0.000003     endif

FUNCTION  tagbar#currenttag()
Called 37 times
Total time:   0.002740
 Self time:   0.001670

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   37              0.000105     let s:statusline_in_use = 1
                            
   37              0.000051     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   37              0.000268         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   37              0.000090         let fullpath  = a:1 =~# 'f'
   37              0.000080         let prototype = a:1 =~# 'p'
   37              0.000028     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   37   0.001141   0.000174     if !s:Init(1)
                                    return a:default
                                endif
                            
   37   0.000248   0.000145     let tag = s:GetNearbyTag(0, 1)
                            
   37              0.000064     if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
   37              0.000040         return a:default
                                endif

FUNCTION  UndotreeUpdate()
Called 37 times
Total time:   0.000312
 Self time:   0.000312

count  total (s)   self (s)
   37              0.000207     if !exists('t:undotree')
   37              0.000049         return
                                endif
                                if !exists('w:undotree_id')
                                    let w:undotree_id = 'id_'.s:getUniqueID()
                                    call s:log("Unique window id assigned: ".w:undotree_id)
                                endif
                                " assume window layout won't change during updating.
                                let thiswinnr = winnr()
                                call t:undotree.Update()
                                " focus moved
                                if winnr() != thiswinnr
                                    call s:exec("norm! ".thiswinnr."\<c-w>\<c-w>")
                                endif

FUNCTION  326()
Called 2 times
Total time:   0.000071
 Self time:   0.000061

count  total (s)   self (s)
    2   0.000028   0.000018     let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
    2              0.000008     let filter = len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
    2              0.000034     return filter(copy(self._rawLoclist), filter)

FUNCTION  328()
Called 1 time
Total time:   0.005619
 Self time:   0.000122

count  total (s)   self (s)
    1   0.000009   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: show')
    1   0.000030   0.000002     call self.setloclist(0)
                            
    1   0.000004   0.000002     if !self.isEmpty()
    1              0.000002         let num = winnr()
    1   0.005482   0.000021         execute 'lopen ' . syntastic#util#var('loc_list_height')
    1              0.000002         if num != winnr()
    1              0.000006             execute num . 'wincmd w'
    1              0.000000         endif
                            
                                    " try to find the loclist window and set w:quickfix_title
    1              0.000015         let errors = getloclist(0)
    3              0.000004         for buf in tabpagebuflist()
    2              0.000010             if buflisted(buf) && bufloaded(buf) && getbufvar(buf, '&buftype') ==# 'quickfix'
    1              0.000002                 let win = bufwinnr(buf)
    1              0.000005                 let title = getwinvar(win, 'quickfix_title')
                            
                                            " TODO: try to make sure we actually own this window; sadly,
                                            " errors == getloclist(0) is the only somewhat safe way to
                                            " achieve that
    1              0.000004                 if strpart(title, 0, 16) ==# ':SyntasticCheck ' || ( (title ==# '' || title ==# ':setloclist()') && errors == getloclist(0) )
    1              0.000004                     call setwinvar(win, 'quickfix_title', ':SyntasticCheck ' . self._name)
    1              0.000004                     call setbufvar(buf, 'syntastic_owner_buffer', self._owner)
    1              0.000000                 endif
    1              0.000000             endif
    2              0.000002         endfor
    1              0.000000     endif

FUNCTION  xolox#misc#os#is_win()
Called 10 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
                              " Returns 1 (true) when on Microsoft Windows, 0 (false) otherwise.
   10              0.000079   return has('win16') || has('win32') || has('win64')

FUNCTION  xolox#misc#path#split()
Called 7543 times
Total time:   0.249473
 Self time:   0.249473

count  total (s)   self (s)
                              " Split a pathname (the first and only argument) into a list of pathname
                              " components.
                              "
                              " On Windows, pathnames starting with two slashes or backslashes are UNC
                              " paths where the leading slashes are significant... In this case we split
                              " like this:
                              "
                              " - Input: `'//server/share/directory'`
                              " - Result: `['//server', 'share', 'directory']`
                              "
                              " Everything except Windows is treated like UNIX until someone has a better
                              " suggestion :-). In this case we split like this:
                              "
                              " - Input: `'/foo/bar/baz'`
                              " - Result: `['/', 'foo', 'bar', 'baz']`
                              "
                              " To join a list of pathname components back into a single pathname string,
                              " use the `xolox#misc#path#join()` function.
 7543              0.018189   if type(a:path) == type('')
 7543              0.007160     if s:windows_compatible
                                  if a:path =~ '^[\/][\/]'
                                    " UNC pathname.
                                    return split(a:path, '\%>2c[\/]\+')
                                  else
                                    " If it's not a UNC pathname we can simply split on slashes and
                                    " backslashes, although we should preserve a leading slash (which
                                    " denotes a pathname that is 'absolute to the current drive').
                                    let absolute = (a:path =~ '^[\/]')
                                    let segments = split(a:path, '[\/]\+')
                                    return absolute ? insert(segments, a:path[0]) : segments
                                  endif
                                else
                                  " Everything else is treated as UNIX.
 7543              0.020902       let absolute = (a:path =~ '^/')
 7543              0.061737       let segments = split(a:path, '/\+')
 7543              0.019176       return absolute ? insert(segments, '/') : segments
                                endif
                              endif
                              return []

FUNCTION  <SNR>78_AutoClose()
Called 3 times
Total time:   0.002467
 Self time:   0.001194

count  total (s)   self (s)
                              " Add matching pair and jump to the midle:
                              " inoremap <silent> <buffer> ( ()<Left>
    3              0.000003   let i = 0
   12   0.000368   0.000091   while i < len(s:get('matchpairs_list'))
    9   0.000471   0.000078     let ld = s:get('left_delims')[i] == '|' ? '<bar>' : s:get('left_delims')[i]
    9   0.000455   0.000067     let rd = s:get('right_delims')[i] == '|' ? '<bar>' : s:get('right_delims')[i]
    9              0.000170     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
    9              0.000095     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
    9              0.000012     let i += 1
    9              0.000008   endwhile
                            
                              " Exit from inside the matching pair:
   12   0.000085   0.000022   for delim in s:get('right_delims')
    9              0.000018     let delim = delim == '|' ? '<bar>' : delim
    9              0.000127     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
    9              0.000086     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
    9              0.000006   endfor
                            
                              " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                              " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
   12   0.000091   0.000021   for delim in s:get('quotes_list')
    9              0.000011     if delim == '|'
                                  let delim = '<Bar>'
                                endif
    9              0.000151     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
    9              0.000082     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
    9              0.000021   endfor
                            
                              " Try to fix the use of apostrophes (kept for backward compatibility):
                              " inoremap <silent> <buffer> n't n't
    3   0.000092   0.000010   for map in s:get('apostrophes_list')
                                exec "inoremap <silent> " . map . " " . map
                                exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
                              endfor

FUNCTION  <SNR>125_create_cache()
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000004   let cache = {'canonicalize_cache': {}, 'exists_cache': {}}
    1              0.000003   function cache.canonicalize(pathname) dict
                                let cache = self['canonicalize_cache']
                                if !empty(a:pathname)
                                  if !has_key(cache, a:pathname)
                                    let cache[a:pathname] = xolox#easytags#utils#canonicalize(a:pathname)
                                  endif
                                  return cache[a:pathname]
                                endif
                                return ''
                              endfunction
    1              0.000002   function cache.exists(pathname) dict
                                let cache = self['exists_cache']
                                if !empty(a:pathname)
                                  if !has_key(cache, a:pathname)
                                    let cache[a:pathname] = filereadable(a:pathname)
                                  endif
                                  return cache[a:pathname]
                                endif
                                return 0
                              endfunction
    1              0.000001   return cache

FUNCTION  <SNR>6_SynSet()
Called 3 times
Total time:   0.002741
 Self time:   0.002551

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    3              0.000048   syn clear
    3              0.000009   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    3              0.000009   let s = expand("<amatch>")
    3              0.000006   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    3              0.000004   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    6              0.000021     for name in split(s, '\.')
    3   0.002582   0.002392       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    3              0.000004     endfor
    3              0.000002   endif

FUNCTION  syntastic#util#bufIsActive()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    1              0.000003     let buf = str2nr(a:buffer)
                            
    1              0.000002     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
    1              0.000003     for tab in range(1, tabpagenr('$'))
    1              0.000004         if index(tabpagebuflist(tab), buf) >= 0
    1              0.000001             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>78_setup()
Called 3 times
Total time:   0.010869
 Self time:   0.000189

count  total (s)   self (s)
    3              0.000007   let swap = a:0 && a:1 == 2
    3              0.000003   let enable = a:0 && a:1
    3              0.000004   let disable = a:0 && !a:1
                              " First, remove all magic, if needed:
    3              0.000009   if get(b:, 'delimitMate_enabled', 0)
    3   0.002056   0.000031     call s:Unmap()
                                " Switch
    3              0.000004     if swap
                                  echo "delimitMate is disabled."
                                  return
                                endif
    3              0.000002   endif
    3              0.000003   if disable
                                " Just disable the mappings.
                                return
                              endif
    3              0.000003   if !a:0
                                " Check if this file type is excluded:
    3              0.000018     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                  " Finish here:
                                  return 1
                                endif
                                " Check if user tried to disable using b:loaded_delimitMate
    3              0.000008     if exists("b:loaded_delimitMate")
                                  return 1
                                endif
    3              0.000002   endif
                              " Initialize settings:
    3   0.004980   0.000020   if ! s:init()
                                " Something went wrong.
                                return
                              endif
    3              0.000010   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                " Now, add magic:
    3   0.003707   0.000012     call s:Map()
    3              0.000002     if a:0
                                  echo "delimitMate is enabled."
                                endif
    3              0.000001   endif

FUNCTION  <SNR>100_OnBufferRead()
Called 3 times
Total time:   0.000059
 Self time:   0.000013

count  total (s)   self (s)
    3   0.000056   0.000010   if !s:AllowedToCompleteInCurrentBuffer()
    3              0.000002     return
                              endif
                            
                              call s:SetUpCompleteopt()
                              call s:SetCompleteFunc()
                              call s:SetOmnicompleteFunc()
                            
                              exec s:python_command "ycm_state.OnBufferVisit()"
                              call s:OnFileReadyToParse()

FUNCTION  <SNR>78_get()
Called 108 times
Total time:   0.002560
 Self time:   0.000458

count  total (s)   self (s)
  108   0.002538   0.000436   return call('delimitMate#Get', a:000)

FUNCTION  <SNR>100_AllowedToCompleteInCurrentBuffer()
Called 39 times
Total time:   0.001744
 Self time:   0.000243

count  total (s)   self (s)
   39   0.001719   0.000218   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>9_LoadFTPlugin()
Called 3 times
Total time:   0.004388
 Self time:   0.004283

count  total (s)   self (s)
    3              0.000010     if exists("b:undo_ftplugin")
    3              0.000034       exe b:undo_ftplugin
    3              0.000013       unlet! b:undo_ftplugin b:did_ftplugin
    3              0.000002     endif
                            
    3              0.000010     let s = expand("<amatch>")
    3              0.000006     if s != ""
    3              0.000019       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    6              0.000022       for name in split(s, '\.')
    3   0.004210   0.004105 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    3              0.000024       endfor
    3              0.000003     endif

FUNCTION  271()
Called 1 time
Total time:   0.000127
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000004     let b:syntastic_private_balloons = {}
    1              0.000005     if has('balloon_eval')
    1   0.000020   0.000007         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
    1              0.000008         unlet! b:syntastic_private_balloons
    1              0.000086         set noballooneval
    1              0.000002     endif

FUNCTION  xolox#easytags#update#parse_entry()
Called 214462 times
Total time:   1.438239
 Self time:   1.438239

count  total (s)   self (s)
214462              1.007408   let fields = split(a:line, '\t')
214462              0.349446   return len(fields) >= 3 ? fields : []

FUNCTION  syntastic#util#screenWidth()
Called 6 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    6              0.000024     let chunks = split(a:str, "\t", 1)
    6              0.000013     let width = s:_width(chunks[-1])
   14              0.000018     for c in chunks[:-2]
    8              0.000015         let cwidth = s:_width(c)
    8              0.000018         let width += cwidth + a:tabstop - cwidth % a:tabstop
    8              0.000012     endfor
    6              0.000005     return width

FUNCTION  xolox#misc#path#is_relative()
Called 7544 times
Total time:   0.069147
 Self time:   0.069147

count  total (s)   self (s)
                              " Returns true (1) when the pathname given as the first argument is
                              " relative, false (0) otherwise.
 7544              0.020239   if a:path =~ '^\w\+://'
                                return 0
                              elseif s:windows_compatible
                                return a:path !~ '^\(\w:\|[\\/]\)'
                              else
 7544              0.014869     return a:path !~ '^/'
                              endif

FUNCTION  xolox#misc#option#eval_tags()
Called 1 time
Total time:   0.000104
 Self time:   0.000054

count  total (s)   self (s)
                              " Evaluate Vim's ['tags' option] [tags] without looking at the file
                              " system, i.e. this will report tags files that don't exist yet. Expects
                              " the value of the ['tags' option] [tags] as the first argument. If the
                              " optional second argument is 1 (true) only the first match is returned,
                              " otherwise (so by default) a list with all matches is returned.
    1              0.000001   let pathnames = []
    1              0.000003   let first_only = exists('a:1') ? a:1 : 0
    1   0.000046   0.000006   for pattern in xolox#misc#option#split_tags(a:value)
                                " Make buffer relative pathnames absolute.
    1              0.000002     if pattern =~ '^\./'
                                  let suffix = matchstr(pattern, '^./\zs.*$')
                                  let directory = (&cpoptions =~# 'd') ? getcwd() : expand('%:p:h')
                                  let pattern = xolox#misc#path#merge(directory, suffix)
                                endif
                                " Make working directory relative pathnames absolute.
    1   0.000015   0.000005     if xolox#misc#path#is_relative(pattern)
                                  let pattern = xolox#misc#path#merge(getcwd(), pattern)
                                endif
                                " Ignore the trailing `;' for recursive upwards searching because we
                                " always want the most specific pathname available.
    1              0.000004     let pattern = substitute(pattern, ';$', '', '')
                                " Expand the pattern.
    1              0.000013     call extend(pathnames, split(expand(pattern), "\n"))
    1              0.000002     if first_only && !empty(pathnames)
    1              0.000002       return pathnames[0]
                                endif
                              endfor
                              return first_only ? '' : pathnames

FUNCTION  xolox#misc#str#ucfirst()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                              " Uppercase the first character in a string (the first argument).
    1              0.000008   return substitute(a:s, '^.', '\U\0', '')

FUNCTION  xolox#misc#option#split_tags()
Called 1 time
Total time:   0.000040
 Self time:   0.000030

count  total (s)   self (s)
                              " Customized version of `xolox#misc#option#split()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              "
                              " [tags]: http://vimdoc.sourceforge.net/htmldoc/options.html#'tags'
    1              0.000010   let values = split(a:value, '[^\\]\zs,')
    1   0.000028   0.000018   return map(values, 's:unescape_tags(v:val)')

FUNCTION  xolox#easytags#update#join_entries()
Called 1 time
Total time:   2.343609
 Self time:   0.912600

count  total (s)   self (s)
    1   2.095142   0.664133   call map(a:values, 'xolox#easytags#update#join_entry(v:val)')
    1              0.248465   return filter(a:values, '!empty(v:val)')

FUNCTION  syntastic#log#debugDump()
Called 1 time
Total time:   0.000012
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000009   0.000005     if !s:_isDebugEnabled(a:level)
    1              0.000001         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>81_addtomrufs()
Called 1 time
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000036 	let fn = fnamemodify(a:fname, ':p')
    1              0.000006 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    1              0.000037 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    1              0.000006 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    1              0.000000 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en

FUNCTION  syntastic#util#wideMsg()
Called 15 times
Total time:   0.148839
 Self time:   0.001445

count  total (s)   self (s)
   15              0.000036     let old_ruler = &ruler
   15              0.000028     let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
   15              0.000105     let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
   15              0.000073     let chunks = split(msg, "\t", 1)
   15              0.000132     let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
   15              0.000059     let msg = strpart(msg, 0, &columns - 1)
                            
   15              0.000123     set noruler noshowcmd
   15   0.147486   0.000092     call syntastic#util#redraw(0)
                            
   15              0.000521     echo msg
                            
   15              0.000108     let &ruler = old_ruler
   15              0.000056     let &showcmd = old_showcmd

FUNCTION  <SNR>125_find_tagged_files()
Called 1 time
Total time:   0.000388
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000003   let tagged_files = {}
    3              0.000006   for entry in a:entries
    2   0.000355   0.000035     let filename = a:cache.canonicalize(entry[1])
    2              0.000003     if filename != ''
    2              0.000005       if !has_key(tagged_files, filename)
    1              0.000002         let tagged_files[filename] = 1
    1              0.000001       endif
    2              0.000001     endif
    2              0.000001   endfor
    1              0.000001   return tagged_files

FUNCTION  xolox#misc#msg#info()
Called 1 time
Total time:   0.018144
 Self time:   0.000021

count  total (s)   self (s)
                              " Show a formatted informational message to the user.
                              "
                              " This function has the same argument handling as Vim's [printf()] []
                              " function with one notable difference: Any arguments which are not numbers
                              " or strings are coerced to strings using Vim's [string()] [] function.
                              "
                              " In the case of `xolox#misc#msg#info()`, automatic string coercion simply
                              " makes the function a bit easier to use.
                              "
                              " The messages emitted by this function have no highlighting. Previously
                              " these messages were highlighted using the [Title group] [hl-title], but it
                              " was pointed out in [pull request 16] [pr-16] that this group shouldn't be
                              " used for informational messages because it is meant for titles and because
                              " of this some color schemes use colors that stand out quite a bit, causing
                              " the informational messages to look like errors.
                              "
                              " [hl-title]: http://vimdoc.sourceforge.net/htmldoc/syntax.html#hl-Title
                              " [pr-16]: https://github.com/xolox/vim-misc/pull/16
                              " [printf()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#printf()
                              " [string()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#string()
    1   0.018136   0.000013   call s:show_message('None', a:000)

FUNCTION  <SNR>78_ExtraMappings()
Called 3 times
Total time:   0.000845
 Self time:   0.000633

count  total (s)   self (s)
                              " If pair is empty, delete both delimiters:
    3              0.000036   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
    3              0.000044   if !hasmapto('<Plug>delimitMateBS','i')
    3              0.000028     if empty(maparg('<BS>', 'i'))
    3              0.000024       silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
    3              0.000001     endif
    3              0.000017     if empty(maparg('<C-H>', 'i'))
    3              0.000035       silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
    3              0.000001     endif
    3              0.000002   endif
                              " If pair is empty, delete closing delimiter:
    3              0.000059   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
    3              0.000037   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
    3              0.000020     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
    3              0.000001   endif
                              " Expand return if inside an empty pair:
    3              0.000034   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
    3   0.000106   0.000021   if s:get('expand_cr') && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
                              endif
                              " Expand space if inside an empty pair:
    3              0.000033   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
    3   0.000077   0.000012   if s:get('expand_space') && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
                              endif
                              " Jump over any delimiter:
    3              0.000034   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
    3   0.000106   0.000044   if s:get('tab2exit') && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
    3              0.000021     silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
    3              0.000002   endif
                              " Jump over next delimiters
    3              0.000037   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
    3              0.000038   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
    3              0.000020     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
    3              0.000001   endif

FUNCTION  xolox#easytags#session_is_loading()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return exists('g:SessionLoad')

FUNCTION  <SNR>100_Pyeval()
Called 36 times
Total time:   0.001593
 Self time:   0.001593

count  total (s)   self (s)
   36              0.000045   if s:using_python3
                                return py3eval( a:eval_string )
                              endif
   36              0.001421   return pyeval( a:eval_string )

FUNCTION  <SNR>78_Map()
Called 3 times
Total time:   0.003695
 Self time:   0.000282

count  total (s)   self (s)
                              " Set mappings:
    3              0.000002   try
    3              0.000006     let save_keymap = &keymap
    3              0.000004     let save_iminsert = &iminsert
    3              0.000004     let save_imsearch = &imsearch
    3              0.000010     let save_cpo = &cpo
    3              0.000017     set keymap=
    3              0.000012     set cpo&vim
    3   0.000067   0.000063     silent! doautocmd <nomodeline> User delimitMate_map
    3   0.000111   0.000014     if s:get('autoclose')
    3   0.002484   0.000017       call s:AutoClose()
    3              0.000017     else
                                  call s:NoAutoClose()
                                endif
    3   0.000870   0.000025     call s:ExtraMappings()
    3              0.000003   finally
    3              0.000017     let &cpo = save_cpo
    3              0.000013     let &keymap = save_keymap
    3              0.000013     let &iminsert = save_iminsert
    3              0.000006     let &imsearch = save_imsearch
    3              0.000003   endtry
                            
    3              0.000005   let b:delimitMate_enabled = 1

FUNCTION  <SNR>49__is_quitting()
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000004     let quitting = 0
    2              0.000008     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    2              0.000004     return quitting

FUNCTION  syntastic#util#fname2buf()
Called 1 time
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    1              0.000019     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    1              0.000009     for md in [':~:.', ':~', ':p']
    1              0.000070         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
    1              0.000003         if buf != -1
    1              0.000003             break
                                    endif
                                endfor
    1              0.000002     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
    1              0.000004     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
    1              0.000002     return buf

FUNCTION  xolox#misc#perm#get()
Called 1 time
Total time:   0.015971
 Self time:   0.000106

count  total (s)   self (s)
                              " Get the owner, group and permissions of the pathname given as the first
                              " argument. Returns an opaque value which you can later pass to
                              " `xolox#misc#perm#set()`.
    1   0.000179   0.000008   let pathname = xolox#misc#path#absolute(a:fname)
    1              0.000019   if filereadable(pathname)
    1              0.000007     let command = printf('stat --format %s %s', '%U:%G:%a', shellescape(pathname))
    1   0.015735   0.000041     let result = xolox#misc#os#exec({'command': command, 'check': 0})
    1              0.000004     if result['exit_code'] == 0 && len(result['stdout']) >= 1
                                  let tokens = split(result['stdout'][0], ':')
                                  if len(tokens) == 3
                                    let [owner, group, mode] = tokens
                                    let mode = '0' . mode
                                    call xolox#misc#msg#debug("vim-misc %s: File %s has owner %s, group %s, mode %s.", g:xolox#misc#version, pathname, owner, group, mode)
                                    return [owner, group, mode]
                                  endif
                                endif
    1              0.000000   endif
    1              0.000002   return []

FUNCTION  xolox#easytags#get_dynamic_tagsfile()
Called 1 time
Total time:   0.000328
 Self time:   0.000047

count  total (s)   self (s)
                              " Get the pathname of the dynamic tags file to use. If the user configured
                              " dynamic tags files this function returns the pathname of the applicable
                              " dynamic tags file (which may not exist yet), otherwise it returns an empty
                              " string.
    1              0.000001   let tagsfile = ''
                              " Look for a suitable project specific tags file?
    1   0.000014   0.000003   let dynamic_files = xolox#misc#option#get('easytags_dynamic_files', 0)
    1              0.000001   if dynamic_files == 1
                                let tagsfile = get(tagfiles(), 0, '')
                              elseif dynamic_files == 2
    1   0.000113   0.000009     let tagsfile = xolox#misc#option#eval_tags(&tags, 1)
    1              0.000003     let directory = fnamemodify(tagsfile, ':h')
    1              0.000010     if filewritable(directory) != 2
                                  " If the directory of the dynamic tags file is not writable, we fall
                                  " back to another type of tags file.
                                  call xolox#misc#msg#warn("easytags.vim %s: Dynamic tags files enabled but %s not writable so falling back.", g:xolox#easytags#version, directory)
                                  let tagsfile = ''
                                endif
    1              0.000000   endif
    1              0.000002   if !empty(tagsfile)
    1   0.000173   0.000007     return s:select_tags_file(tagsfile, 'dynamic')
                              endif
                              return ''

FUNCTION  syntastic#c#ReadConfig()
Called 1 time
Total time:   0.000426
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000028   0.000018     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: looking for', a:file)
                            
                                " search upwards from the current file's directory
    1   0.000376   0.000040     let config = syntastic#util#findFileInParent(a:file, expand('%:p:h', 1))
    1              0.000002     if config ==# ''
    1   0.000015   0.000006         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: file not found')
    1              0.000001         return ''
                                endif
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: config file:', config)
                                if !filereadable(config)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: file unreadable')
                                    return ''
                                endif
                            
                                " convert filename into absolute path
                                let filepath = fnamemodify(config, ':p:h')
                            
                                " try to read config file
                                try
                                    let lines = readfile(config)
                                catch /\m^Vim\%((\a\+)\)\=:E48[45]/
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: error reading file')
                                    return ''
                                endtry
                            
                                " filter out empty lines and comments
                                call filter(lines, 'v:val !~# ''\v^(\s*#|$)''')
                            
                                " remove leading and trailing spaces
                                call map(lines, 'substitute(v:val, ''\m^\s\+'', "", "")')
                                call map(lines, 'substitute(v:val, ''\m\s\+$'', "", "")')
                            
                                let parameters = []
                                for line in lines
                                    let matches = matchstr(line, '\m\C^\s*-I\s*\zs.\+')
                                    if matches !=# ''
                                        " this one looks like an absolute path
                                        if match(matches, '\m^\%(/\|\a:\)') != -1
                                            call add(parameters, '-I' . matches)
                                        else
                                            call add(parameters, '-I' . filepath . syntastic#util#Slash() . matches)
                                        endif
                                    else
                                        call add(parameters, line)
                                    endif
                                endfor
                            
                                return join(map(parameters, 'syntastic#util#shescape(v:val)'))

FUNCTION  SyntasticMake()
Called 1 time
Total time:   0.055842
 Self time:   0.003689

count  total (s)   self (s)
    1   0.000017   0.000007     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    1              0.000003     let old_local_errorformat = &l:errorformat
    1              0.000002     let old_errorformat = &errorformat
    1              0.000026     let old_cwd = getcwd()
                                " }}}3
                            
    1              0.000004     if has_key(a:options, 'errorformat')
    1              0.000009         let &errorformat = a:options['errorformat']
    1              0.000003         set errorformat<
    1              0.000001     endif
                            
    1              0.000002     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    1              0.000002     let env_save = {}
    1              0.000003     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_][a-z0-9_]*$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
    1   0.044195   0.000060     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    1              0.000005     if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
    1   0.000049   0.000034     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    1   0.000051   0.000018     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    1              0.000001     if !bailout
    1              0.000004         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    1              0.003121         noautocmd lgetexpr err_lines
                            
    1              0.000179         let errors = deepcopy(getloclist(0))
                            
    1              0.000004         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    1              0.000001         try
    1   0.007977   0.000029             silent lolder
    1              0.000001         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                        try
                                            " Vim 7.4.2200 or later
                                            call setloclist(0, [], 'r', { 'title': '' })
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
                                        endtry
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    1              0.000001     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    1              0.000005     let &errorformat = old_errorformat
    1              0.000003     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    1   0.000017   0.000013     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    1              0.000001     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
    1   0.000014   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    1              0.000002     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
    1              0.000002     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    1              0.000003     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
    1              0.000002     return errors

FUNCTION  xolox#easytags#update#read_tagsfile()
Called 1 time
Total time:   4.886060
 Self time:   3.447854

count  total (s)   self (s)
                              " I'm not sure whether this is by design or an implementation detail but
                              " it's possible for the "!_TAG_FILE_SORTED" header to appear after one or
                              " more tags and Vim will apparently still use the header! For this reason
                              " the xolox#easytags#update#write_tagsfile() function should also recognize it,
                              " otherwise Vim might complain with "E432: Tags file not sorted".
    1              0.000002   let headers = []
    1              0.000001   let entries = []
    1              0.000002   let num_invalid = 0
    1              0.000018   if filereadable(a:tagsfile)
    1              0.133890     let lines = readfile(a:tagsfile)
    1              0.000005   else
                                let lines = []
                              endif
214467              0.201642   for line in lines
214466              0.425373     if line =~# '^!_TAG_'
    6              0.000014       call add(headers, line)
    6              0.000004     else
214460   2.087852   0.649646       let entry = xolox#easytags#update#parse_entry(line)
214460              0.288011       if !empty(entry)
214460              0.328518         call add(entries, entry)
214460              0.112555       else
                                    let num_invalid += 1
                                  endif
214460              0.094616     endif
214466              0.434921   endfor
    1              0.000002   if num_invalid > 0
                                call xolox#misc#msg#warn("easytags.vim %s: Ignored %i invalid line(s) in %s!", g:xolox#easytags#version, num_invalid, a:tagsfile)
                              endif
    1              0.000002   return [headers, entries]

FUNCTION  <SNR>58_coerce_argument()
Called 5 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                              " Callback to coerce printf() arguments into strings.
    5              0.000020   let value_type = type(a:value)
    5              0.000011   if value_type != type(0) && value_type != type('')
                                return string(a:value)
                              else
    5              0.000005     return a:value
                              endif

FUNCTION  <SNR>78_option_init()
Called 69 times
Total time:   0.003355
 Self time:   0.001165

count  total (s)   self (s)
   69              0.000227   let b = exists("b:delimitMate_" . a:name)
   69              0.000191   let g = exists("g:delimitMate_" . a:name)
                              " Find value to use.
   69              0.000065   if !b && !g
   69              0.000086     let value = a:default
   69              0.000051   elseif b
                                exec "let value = b:delimitMate_" . a:name
                              else
                                exec "let value = g:delimitMate_" . a:name
                              endif
   69   0.002435   0.000245   call s:set(a:name, value)

FUNCTION  syntastic#util#unique()
Called 7 times
Total time:   0.000429
 Self time:   0.000429

count  total (s)   self (s)
    7              0.000012     let seen = {}
    7              0.000011     let uniques = []
   37              0.000037     for e in a:list
   30              0.000070         let k = string(e)
   30              0.000064         if !has_key(seen, k)
   12              0.000022             let seen[k] = 1
   12              0.000030             call add(uniques, e)
   12              0.000009         endif
   30              0.000030     endfor
    7              0.000008     return uniques

FUNCTION  266()
Called 1 time
Total time:   0.005709
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000019   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    1   0.005688   0.000003     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  267()
Called 1 time
Total time:   0.005685
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000009   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    1   0.000013   0.000003     let auto_loc_list = syntastic#util#var('auto_loc_list')
    1   0.000004   0.000002     if !a:loclist.isEmpty()
    1              0.000001         if auto_loc_list == 1 || auto_loc_list == 3
    1   0.005634   0.000015             call a:loclist.show()
    1              0.000001         endif
    1              0.000000     else
                                    if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
                                    endif
                                endif

FUNCTION  269()
Called 2 times
Total time:   0.000030
 Self time:   0.000008

count  total (s)   self (s)
    2   0.000030   0.000008     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  <SNR>42__is_same_index()
Called 36 times
Total time:   0.000730
 Self time:   0.000730

count  total (s)   self (s)
   36              0.000107     if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
                                    if len(a:messages) <= 1
                                        return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
   36              0.000038         return 0
                                endif

FUNCTION  syntastic#util#setLastTick()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000011     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  270()
Called 1 time
Total time:   0.000296
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000002     unlet! b:syntastic_private_balloons
    1   0.000029   0.000013     if self.enabled() && !a:loclist.isEmpty()
    1   0.000205   0.000007         let b:syntastic_private_balloons = a:loclist.balloons()
    1              0.000002         if !empty(b:syntastic_private_balloons)
    1              0.000055             set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  xolox#misc#os#exec()
Called 2 times
Total time:   0.033710
 Self time:   0.001519

count  total (s)   self (s)
                              " Execute an external command (hiding the console on Microsoft Windows when
                              " my [vim-shell plug-in] [vim-shell] is installed).
                              "
                              " Expects a dictionary with the following key/value pairs as the first
                              " argument:
                              "
                              " - **command** (required): The command line to execute
                              " - **async** (optional): set this to 1 (true) to execute the command in the
                              "   background (asynchronously)
                              " - **stdin** (optional): a string or list of strings with the input for the
                              "   external command
                              " - **check** (optional): set this to 0 (false) to disable checking of the
                              "   exit code of the external command (by default an exception will be
                              "   raised when the command fails)
                              "
                              " Returns a dictionary with one or more of the following key/value pairs:
                              "
                              " - **command** (always available): the generated command line that was used
                              "   to run the external command
                              " - **exit_code** (only in synchronous mode): the exit status of the
                              "   external command (an integer, zero on success)
                              " - **stdout** (only in synchronous mode): the output of the command on the
                              "   standard output stream (a list of strings, one for each line)
                              " - **stderr** (only in synchronous mode): the output of the command on the
                              "   standard error stream (as a list of strings, one for each line)
                              "
                              " [vim-shell]: http://peterodding.com/code/vim/shell/
    2              0.000001   try
                            
                                " Unpack the options.
    2              0.000005     let cmd = a:options['command']
    2              0.000005     let async = get(a:options, 'async', 0)
                            
                                " We need to know in a couple of places whether we are on Windows.
    2   0.000023   0.000005     let is_win = xolox#misc#os#is_win()
                            
                                " Use vim-shell so we don't pop up a console window on Windows? If the
                                " caller specifically asks us *not* to use vim-shell, we'll respect that
                                " choice; this is very useful for automated tests :-).
    2              0.000004     if get(a:options, 'use_dll', 1) == 0
                                  let use_dll = 0
                                else
    2   0.000605   0.000014       let use_dll = xolox#misc#os#can_use_dll()
    2              0.000001     endif
                            
                                " Decide whether to redirect the standard output and standard error
                                " streams to temporary files.
    2              0.000004     let redirect_output = !async && (use_dll || !is_win)
                            
                                " Write the input for the external command to a temporary file?
    2              0.000005     if has_key(a:options, 'stdin') && use_dll
                                  let tempin = tempname()
                                  if type(a:options['stdin']) == type([])
                                    let lines = a:options['stdin']
                                  else
                                    let lines = split(a:options['stdin'], "\n")
                                  endif
                                  call writefile(lines, tempin)
                                  let cmd .= ' < ' . xolox#misc#escape#shell(tempin)
                                endif
                            
                                " Redirect the standard output and/or standard error streams of the
                                " external process to temporary files? (only in synchronous mode)
    2              0.000002     if redirect_output
    2              0.000006       let tempout = tempname()
    2              0.000003       let temperr = tempname()
    2   0.000123   0.000027       let cmd = printf('(%s) 1>%s 2>%s', cmd, xolox#misc#escape#shell(tempout), xolox#misc#escape#shell(temperr))
    2              0.000001     endif
                            
                                " Use vim-shell or system() to execute the external command?
    2              0.000002     if use_dll
                                  call xolox#misc#msg#debug("vim-misc %s: Executing external command using compiled DLL: %s", g:xolox#misc#version, cmd)
                                  let exit_code = xolox#shell#execute_with_dll(cmd, async)
                                else
                            
                                  " Enable asynchronous mode (very platform specific).
    2              0.000001       if async
                                    if is_win
                                      " As pointed out in issue 17 [1] the use of `:!start' on Windows
                                      " requires characters like `!', `%' and `#' to be escaped with a
                                      " backslash [2]. Vim's shellescape() function knows how to escape
                                      " these special characters however the use of `:!start' is an
                                      " implementation detail of xolox#misc#os#exec() so I don't want to
                                      " bother callers (who perform the shell escaping) with such a
                                      " specific implementation detail. This is why I resort to manually
                                      " escaping characters documented to have a special meaning [2].
                                      "
                                      " [1] https://github.com/xolox/vim-misc/issues/17
                                      " [2] All characters interpreted specially in shell command lines
                                      "     executed from Vim's command mode, refer to `:help :!' for
                                      "     details.
                                      let cmd = printf('start /b %s', escape(cmd, "\\\n!%#"))
                                    elseif has('unix')
                                      let cmd = printf('(%s) &', cmd)
                                    else
                                      call xolox#misc#msg#warn("vim-misc %s: I don't know how to execute the command %s asynchronously on your platform! Falling back to synchronous mode...", g:xolox#misc#version, cmd)
                                    endif
                                  endif
                            
                                  " On UNIX we explicitly execute the command line using 'sh' instead of
                                  " the default shell, because we assume that standard output and standard
                                  " error can be redirected separately, but (t)csh does not support this
                                  " (and it might be the default shell).
    2              0.000002       if has('unix')
    2   0.000028   0.000011         call xolox#misc#msg#debug("vim-misc %s: Generated shell expression: %s", g:xolox#misc#version, cmd)
    2   0.000058   0.000009         let cmd = printf('sh -c %s', xolox#misc#escape#shell(cmd))
    2              0.000001       endif
                            
                                  " Let the user know what's happening (in case they're interested).
    2              0.000002       if async && is_win
                                    call xolox#misc#msg#debug("vim-misc %s: Executing external command using !start command: %s", g:xolox#misc#version, cmd)
                                    silent execute '!' . cmd
                                  else
    2   0.000024   0.000010         call xolox#misc#msg#debug("vim-misc %s: Executing external command using system() function: %s", g:xolox#misc#version, cmd)
    2              0.000004         let arguments = [cmd]
    2              0.000004         if has_key(a:options, 'stdin')
                                      if type(a:options['stdin']) == type([])
                                        call add(arguments, join(a:options['stdin'], "\n"))
                                      else
                                        call add(arguments, a:options['stdin'])
                                      endif
                                    endif
    2   0.031900   0.000650         let stdout = call('system', arguments)
    2              0.000018         let exit_code = v:shell_error
    2              0.000004       endif
                            
    2              0.000002     endif
                            
                                " Return the results as a dictionary with one or more key/value pairs.
    2              0.000019     let result = {'command': cmd}
    2              0.000004     if !async
    2              0.000009       let result['exit_code'] = exit_code
                                  " Get the standard output of the command.
    2              0.000003       if redirect_output
    2   0.000152   0.000054         let result['stdout'] = s:readfile(tempout, 'standard output', a:options['command'])
    2              0.000006       elseif exists('stdout')
                                    let result['stdout'] = split(stdout, "\n")
                                  else
                                    let result['stdout'] = []
                                  endif
                                  " Get the standard error of the command.
    2              0.000007       if exists('temperr')
    2   0.000076   0.000018         let result['stderr'] = s:readfile(temperr, 'standard error', a:options['command'])
    2              0.000002       else
                                    let result['stderr'] = []
                                  endif
                                  " If we just executed a synchronous command and the caller didn't
                                  " specifically ask us *not* to check the exit code of the external
                                  " command, we'll do so now. The idea here is that it should be easy
                                  " to 'do the right thing'.
    2              0.000009       if get(a:options, 'check', 1) && exit_code != 0
                                    " Prepare an error message with enough details so the user can investigate.
                                    let msg = printf("vim-misc %s: External command failed with exit code %d!", g:xolox#misc#version, result['exit_code'])
                                    let msg .= printf("\nCommand line: %s", result['command'])
                                    " If the external command reported an error, we'll include it in our message.
                                    if !empty(result['stderr'])
                                      " This is where we would normally expect to find an error message.
                                      let msg .= printf("\nOutput on standard output stream:\n%s", join(result['stderr'], "\n"))
                                    elseif !empty(result['stdout'])
                                      " Exuberant Ctags on Windows XP reports errors on standard output :-x.
                                      let msg .= printf("\nOutput on standard error stream:\n%s", join(result['stdout'], "\n"))
                                    endif
                                    throw msg
                                  endif
    2              0.000001     endif
    2              0.000002     return result
                            
                              finally
                                " Cleanup any temporary files we created.
    8              0.000025     for name in ['tempin', 'tempout', 'temperr']
    6              0.000020       if exists(name)
    4              0.000262         call delete({name})
    4              0.000006       endif
    6              0.000005     endfor
    2              0.000006   endtry
                            

FUNCTION  273()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return self._filetype

FUNCTION  275()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006     return self._filetype . '/' . self._name

FUNCTION  276()
Called 1 time
Total time:   0.000098
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000001     if a:0
                                    let self._exec = a:1
                                else
    1              0.000003         let suffix = self._name . '_exec'
    1   0.000088   0.000052         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    1              0.000001     endif

FUNCTION  279()
Called 1 time
Total time:   0.057163
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000003     let checker_start = reltime()
    1   0.000007   0.000004     let name = self.getCName()
                            
    1              0.000003     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
    1              0.000001     try
    1   0.056936   0.000011         let list = self._locListFunc()
    1              0.000002         if self._exec !=# ''
    1   0.000015   0.000008             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    1              0.000001         endif
    1              0.000001     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    1   0.000020   0.000007     call self._populateHighlightRegexes(list)
    1   0.000012   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    1   0.000094   0.000007     call self._quietMessages(list)
    1   0.000024   0.000017     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
    1              0.000003     return list

FUNCTION  xolox#misc#option#get()
Called 7553 times
Total time:   0.088801
 Self time:   0.088801

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
 7553              0.019381   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
 7551              0.016705     return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
    1              0.000001     return a:1
                              endif

FUNCTION  <SNR>79_set()
Called 69 times
Total time:   0.001570
 Self time:   0.001570

count  total (s)   self (s)
   69              0.000086   let scope = a:0 ? a:1 : 's'
   69              0.000185   let bufnr = bufnr('%')
   69              0.000196   if !exists('s:options[bufnr]')
                                let s:options[bufnr] = {}
                              endif
   69              0.000077   if scope == 's'
   69              0.000184     let name = 's:options.' . bufnr . '.' . a:name
   69              0.000039   else
                                let name = scope . ':delimitMate_' . a:name
                                if exists('name')
                                  exec 'unlet! ' . name
                                endif
                              endif
   69              0.000307   exec 'let ' . name . ' = a:value'

FUNCTION  xolox#easytags#autoload()
Called 1 time
Total time:  13.432574
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000001   try
    1   0.000008   0.000005     let session_loading = xolox#easytags#session_is_loading() && a:event == 'BufReadPost'
    1   0.000020   0.000007     let do_update = xolox#misc#option#get('easytags_auto_update', 1) && !session_loading
    1   0.000013   0.000003     let do_highlight = xolox#misc#option#get('easytags_auto_highlight', 1) && &eventignore !~? '\<syntax\>'
                                " Don't execute this function for unsupported file types (doesn't load
                                " the list of file types if updates and highlighting are both disabled).
    1   0.000068   0.000006     if (do_update || do_highlight) && !empty(xolox#easytags#filetypes#canonicalize(&filetype))
                                  " Update entries for current file in tags file?
    1              0.000001       if do_update
    1              0.000004         let buffer_read = (a:event =~? 'BufReadPost')
    1              0.000004         let buffer_written = (a:event =~? 'BufWritePost')
    1              0.000002         if buffer_written || (buffer_read && xolox#misc#option#get('easytags_always_enabled', 0))
    1  13.432425   0.000024           call xolox#easytags#update(1, 0, [])
    1              0.000002         endif
    1              0.000000       endif
                                  " Apply highlighting of tags to current buffer?
    1              0.000001       if do_highlight
                                    if !exists('b:easytags_last_highlighted')
                                      call xolox#easytags#highlight()
                                    else
                                      for tagfile in tagfiles()
                                        if getftime(tagfile) > b:easytags_last_highlighted
                                          call xolox#easytags#highlight()
                                          break
                                        endif
                                      endfor
                                    endif
                                    let b:easytags_last_highlighted = localtime()
                                  endif
    1              0.000001     endif
    1              0.000001   catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
                              endtry

FUNCTION  xolox#easytags#update#join_entry()
Called 214460 times
Total time:   1.431009
 Self time:   1.431009

count  total (s)   self (s)
214460              1.385458   return type(a:value) == type([]) ? join(a:value, "\t") : a:value

FUNCTION  <SNR>100_DisableOnLargeFile()
Called 36 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
   36              0.000107   if exists( 'b:ycm_largefile' )
   36              0.000052     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  <SNR>42__find_index()
Called 15 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   15              0.000054     let max = len(a:messages) - 1
   15              0.000018     if max == 0
    6              0.000007         return 0
                                endif
    9              0.000010     let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
    9              0.000021     while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
    9              0.000039     return a:column < a:messages[max].scol ? min : max

FUNCTION  <SNR>100_AllowedToCompleteInBuffer()
Called 39 times
Total time:   0.001501
 Self time:   0.001306

count  total (s)   self (s)
   39              0.000231   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
   39              0.000260   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
    3              0.000002     return 0
                              endif
                            
   36   0.000355   0.000160   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
   36              0.000200   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
   36              0.000139   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
   36              0.000056   return whitelist_allows && blacklist_allows

FUNCTION  280()
Called 1 time
Total time:   0.057314
 Self time:   0.000038

count  total (s)   self (s)
    1   0.057314   0.000038     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  285()
Called 1 time
Total time:   0.000120
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000102   0.000004     call self.syncExec()
                            
    1              0.000003     if !has_key(self, '_available')
                                    let self._available = {}
                                endif
    1              0.000003     if !has_key(self._available, self._exec)
                                    let self._available[self._exec] = self._isAvailableFunc()
                                endif
                            
    1              0.000002     return self._available[self._exec]

FUNCTION  287()
Called 1 time
Total time:   0.000029
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000028   0.000015     return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)

FUNCTION  289()
Called 1 time
Total time:   0.000087
 Self time:   0.000042

count  total (s)   self (s)
                                " wildcard quiet_messages
    1   0.000033   0.000006     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    1              0.000004     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    1              0.000003     let name = self._filetype . '_' . self._name
    1              0.000000     try
    1   0.000017   0.000006         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    1              0.000001     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    1   0.000011   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    1              0.000002     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  syntastic#util#rawVar()
Called 20 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
   20              0.000107     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  <SNR>81_record()
Called 1 time
Total time:   0.000138
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000002 	if s:locked | retu | en
    1              0.000002 	let bufnr = a:bufnr + 0
    1              0.000003 	let bufname = bufname(bufnr)
    1              0.000002 	if bufnr > 0 && !empty(bufname)
    1              0.000010 		cal filter(s:mrbs, 'v:val != bufnr')
    1              0.000002 		cal insert(s:mrbs, bufnr)
    1   0.000116   0.000010 		cal s:addtomrufs(bufname)
    1              0.000000 	en

FUNCTION  syntastic#util#shexpand()
Called 2 times
Total time:   0.000037
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000036   0.000018     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  290()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  293()
Called 2 times
Total time:   0.000029
 Self time:   0.000007

count  total (s)   self (s)
    2   0.000028   0.000006     return syntastic#util#var('echo_current_error')

FUNCTION  294()
Called 1 time
Total time:   0.001023
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000020   0.000004     if self.enabled() && !a:loclist.isEmpty()
    1   0.000011   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
    1   0.000975   0.000010         let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
    1              0.000001         let b:syntastic_private_line = -1
    1   0.000007   0.000005         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
    1              0.000003         autocmd! syntastic CursorMoved
    1              0.000003         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    1              0.000000     endif

FUNCTION  295()
Called 1 time
Total time:   0.000036
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000014   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    1              0.000007     autocmd! syntastic CursorMoved
    1              0.000011     unlet! b:syntastic_private_messages
    1              0.000002     let b:syntastic_private_line = -1

FUNCTION  297()
Called 2 times
Total time:   0.000031
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000031   0.000009     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  298()
Called 1 time
Total time:   0.000386
 Self time:   0.000342

count  total (s)   self (s)
    1   0.000017   0.000003     if self.enabled()
    1   0.000012   0.000003         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    1   0.000023   0.000005         call self._reset()
    1              0.000002         let buf = bufnr('')
    1   0.000014   0.000011         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
   10              0.000011         for item in issues
    9              0.000040             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
    9              0.000014             if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
    9              0.000012                 if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
    9              0.000025                     let lastcol = col([item['lnum'], '$'])
    9              0.000010                     let coltype = 'c'
    9              0.000006                 endif
    9              0.000023                 let lcol = min([lastcol, item['col']])
                            
    9              0.000059                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
    9              0.000003             endif
    9              0.000004         endfor
    1              0.000001     endif

FUNCTION  299()
Called 1 time
Total time:   0.000193
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000002     if s:has_highlighting
    1   0.000013   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    1   0.000174   0.000006         call self._reset()
    1              0.000000     endif

FUNCTION  <SNR>121_GetNearbyTag()
Called 37 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   37              0.000039     if s:nearby_disabled
   37              0.000039         return {}
                                endif
                            
                                let fileinfo = s:TagbarState().getCurrent(a:forcecurrent)
                                if empty(fileinfo)
                                    return {}
                                endif
                            
                                let typeinfo = fileinfo.typeinfo
                                if a:0 > 0
                                    let curline = a:1
                                else
                                    let curline = line('.')
                                endif
                                let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
                                for line in range(curline, 1, -1)
                                    if has_key(fileinfo.fline, line)
                                        let curtag = fileinfo.fline[line]
                                        if a:all || typeinfo.getKind(curtag.fields.kind).stl
                                            let tag = curtag
                                            break
                                        endif
                                    endif
                                endfor
                            
                                return tag

FUNCTION  delimitMate#Set()
Called 69 times
Total time:   0.001907
 Self time:   0.000337

count  total (s)   self (s)
   69   0.001894   0.000324   return call('s:set', a:000)

FUNCTION  <SNR>49_CacheErrors()
Called 1 time
Total time:   0.059663
 Self time:   0.000482

count  total (s)   self (s)
    1   0.000027   0.000014     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    1   0.001049   0.000137     call s:ClearCache(a:buf)
    1   0.000052   0.000008     let newLoclist = g:SyntasticLoclist.New([])
    1   0.000011   0.000005     call newLoclist.setOwner(a:buf)
                            
    1   0.000118   0.000005     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    1   0.000016   0.000006         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    1   0.000033   0.000021         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
    1   0.000017   0.000008             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    1   0.000014   0.000006             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    1              0.000001         endif
    1   0.000016   0.000008         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    1   0.000028   0.000020         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    1   0.000314   0.000013         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    1   0.000071   0.000023         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    1              0.000003         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    1              0.000003         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    1              0.000002         let names = []
    1              0.000002         let unavailable_checkers = 0
    1              0.000002         for checker in clist
    1   0.000010   0.000006             let cname = checker.getCName()
    1   0.000144   0.000024             if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
    1   0.000016   0.000007             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    1   0.057325   0.000011             let loclist = checker.getLocList()
                            
    1   0.000007   0.000004             if !loclist.isEmpty()
    1              0.000001                 if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
    1              0.000003                 call add(names, cname)
    1   0.000033   0.000004                 if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
    1   0.000014   0.000004                 call newLoclist.extend(loclist)
                            
    1              0.000001                 if !aggregate_errors
    1              0.000001                     break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
    1              0.000002         if !empty(names)
    1   0.000044   0.000017             if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
    1              0.000006                 let type = substitute(names[0], '\m/.*', '', '')
    1              0.000010                 let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
    1   0.000008   0.000006                 call newLoclist.setName( name . ' ('. type . ')' )
    1              0.000001             else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
    1              0.000000         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    1              0.000002         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    1   0.000012   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    1              0.000002         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    1              0.000001     endif
                            
    1   0.000168   0.000004     call newLoclist.deploy()

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1  13.432574   0.000085  xolox#easytags#autoload()
    1  13.432401   0.005421  xolox#easytags#update()
    1  13.407920   0.115128  xolox#easytags#update#with_vim()
    1  13.274298   0.862272  <SNR>125_filter_merge_tags()
    1   4.886060   3.447854  xolox#easytags#update#read_tagsfile()
    1   4.353746   0.129015  xolox#easytags#update#write_tagsfile()
    1   2.343609   0.912600  xolox#easytags#update#join_entries()
    1   1.881105   1.865045  xolox#misc#perm#update()
214462   1.438239             xolox#easytags#update#parse_entry()
214460   1.431009             xolox#easytags#update#join_entry()
 7541   1.253511   0.069704  xolox#easytags#utils#canonicalize()
 7543   0.951691   0.512115  xolox#misc#path#absolute()
 7543   0.249473             xolox#misc#path#split()
 7542   0.232445   0.143782  xolox#easytags#utils#resolve()
   36   0.154097   0.004260  SyntasticRefreshCursor()
   15   0.148839   0.001445  syntastic#util#wideMsg()
   15   0.147394             syntastic#util#redraw()
 7543   0.120966             xolox#misc#path#join()
    1   0.098349   0.000059  <SNR>49_BufWritePostHook()
    1   0.098123   0.000208  <SNR>49_UpdateErrors()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1   4.886060   3.447854  xolox#easytags#update#read_tagsfile()
    1   1.881105   1.865045  xolox#misc#perm#update()
214462              1.438239  xolox#easytags#update#parse_entry()
214460              1.431009  xolox#easytags#update#join_entry()
    1   2.343609   0.912600  xolox#easytags#update#join_entries()
    1  13.274298   0.862272  <SNR>125_filter_merge_tags()
 7543   0.951691   0.512115  xolox#misc#path#absolute()
 7543              0.249473  xolox#misc#path#split()
   15              0.147394  syntastic#util#redraw()
 7542   0.232445   0.143782  xolox#easytags#utils#resolve()
    1   4.353746   0.129015  xolox#easytags#update#write_tagsfile()
 7543              0.120966  xolox#misc#path#join()
    1  13.407920   0.115128  xolox#easytags#update#with_vim()
 7553              0.088801  xolox#misc#option#get()
 7541   1.253511   0.069704  xolox#easytags#utils#canonicalize()
 7544              0.069147  xolox#misc#path#is_relative()
    1   0.018123   0.018072  <SNR>58_show_message()
   37              0.013952  <SNR>89_Highlight_Matching_Pair()
    1   0.011781   0.011640  361()
    1   0.011471   0.011388  362()

